[{"title":"swift笔记一:基础内容","date":"2019-06-11T03:13:53.000Z","path":"2019/06/11/swift笔记一-基础内容/","text":"常量和变量用关键字let来声明常量,用var来声明变量,在swift中,如果值不发生改变都应该用let声明为常量. 123let a = 10var b = 100let c = 1,d = 2,e = 3 关于常量和变量的类型,一般我们不需要主动标注出常量和变量的类型,当我们给常量变量初始化赋值后,swift会自动推断类型 整数会被推断为Int类型,而浮点数则会被推断为Double类型 如果要打印某个变量则,格式如下: 123print(a) print(\"fdasfdafda\\(a)\") 整数整数类型有Int,Int8,Int16,Int32,Int64,我们一般使用Int就OK了,Int在32位平台上等于Int32,在64位平台上等于Int64 我们可以这样取到类型最大最小值: 1print(Int.max,Int.min) UInt是无符号整数,但是因为容错等问题,我们还是推荐使用Int 浮点数浮点数有Double和Float两种类型,Double类型为64位浮点数至少有15位精度,而Float位32位浮点数,只有6位精度,浮点数的默认类型和推荐类型是Double 数值字面量关于各个进制的前缀: 1234567let g = 17//十进制 let h = 0b10001//二进制 let i = 0o21//八进制 let j = 0x11//十六进制 print(g,h,i,j) 17 17 17 17//打印结果 浮点数指数: 12345let k = 1.25e2//相当于1.25*10^2 let l = 1.25e-2//相当于1.25*10^-2 print(k,l) 125.0 0.0125//打印结果 为了可阅读性,增加_不影响值: 123let m = 1000_000_0_0 print(m) 100000000//打印结果 类型转换对于不同类型的值并不能直接进行计算即使是Int8和Int16,所以我们要进行类型转换,转换方式如下: 1234let n :Int8 = 1 let o :Int16 = 2 print(Int16(n)+o) 值得注意的是,如果我们将浮点数转化为整数,则小数部分会被直接丢弃,而不是四舍五入 别名有时候,我们为了可读性,会根据语境为某个类型创建一个可阅读的别名,格式如下: 1234let n :Int8 = 1 let o :Int16 = 2 print(Int16(n)+o) 布尔值swift的布尔值类型为Bool,它的两个值为true,false 在swift中if后面的条件语句必须是一个布尔值,而不能用其它替代,例如 1234let q = 1 if q &#123;//不能通过编译,会报错 print(111) &#125; 元组元组是swift新引入的类型,以下是元组的各种常见语法: 12345678910111213141516let r = (1,\"1\")print(r) let (num,str) = rprint(num,str) let (num1,_) = rprint(num1) print(r.0,r.1) let r1 = (1,2,3,4,5,\"6\",3.2)print(r1) let r2 = (r2Num:1,r2Str:\"str\")print(r2.r2Num,r2.r2Str) 可选项如果一个变量或者常量是一个可选类型例如Int?,则代表这个变量或者常量可能是一个Int值也可能没有值. 我们可以给一个可选类型变量赋值一个nil,将这个变量设为没有值.如下: 12345var s:Int? = 12print(s) s=nilprint(s) 值得注意的是,和OC不同swift中的nil不止能用在对象上,它可以用在任何可选类型上,代表没有值 可选绑定可选绑定,是一种展开可选项的语法,通过在if或者while的条件判断语句中,将一个可选变量或常量,赋值给一个新的变量或者常量,这个新的值会是一个不可选类型,如果可选变量或者常量是有值的,那么新的值就被成功赋值了,并且条件语句的布尔值为true,在之后的执行语句中就可以用这个新的值了,因为新的值是一个不可选类型,所以使用时候不需要加! 123456789var s:Int? = 12print(s) if let s1 = s &#123; print(s1)&#125;else&#123; print(\"s没有值\")&#125; 隐式展开可选项在可选项变量或者常量后面加个!表明,这个可选项一定有值,可以安全使用 12345var s:Int? = nil if s != nil &#123; print(s!+5)&#125; 遗留待整理问题 错误处理 断言和先决条件 使用断言进行调试 强制先决条件","tags":[{"name":"swift笔记","slug":"swift笔记","permalink":"https://cxlhaha.github.io/tags/swift笔记/"}]},{"title":"iOS绘制和渲染","date":"2018-11-17T08:08:19.000Z","path":"2018/11/17/iOS绘制和渲染/","text":"前言我们平常iOS开发中，很少有机会能够深入的了解绘制和渲染详细的底层过程，在UI显示方面，我们大多时候都只知其然而不知其所以然，然后在遇到一些UI方面的性能问题，内存问题，这部分知识就尤其重要了，我们今天就来探究一下iOS绘制渲染的整个过程。 相关框架 这张截图是苹果官方文档中，关于视觉相关的一个框架结构图。 UIKit 我们可以看到，最上层的框架就是我们平时开发最常用到的UIKit（Mac开发是AppKit）UIkit为我们封装了大量的视图，窗口，视图结构等丰富的UI元素，以及事件处理结构，文本图像支持等等，我们可以直接使用UIKit来完成我们平时开发中绝大多数视图的相关实现，非常简单方便。 CoreAnimation（QuartzCore） 在接下来的底层基础设施中，最上层的框架为CoreAnimation，提到CoreAnimation，我们可能会想到它是动画相关功能的库，这其实是对它非常大的一个误解，实际上，动画功能只是CoreAnimation的一部分，它的原名叫做LayerKit，这样一说，你就能知道，它正真的核心是什么了吧，CoreAnimation组合了不同的可视视图，形成一个个独立的图层，存储在图层树中，而UIKit的UIView视觉显示上完全依赖这个图层，UIView封装了CALayer并添加了一些CALayer并不具备的功能，例如交互事件等。 CoreGraphics CoreGraphics是底层绘图框架，我们平时可以直接调用它的API做一些自定义视图，它使用了Quartz2D引擎，calyer是CoreGraphics封装出来的图层类，calayer知道如何利用CoreGraphics绘制自己。 Metal Metal是苹果最新推出的底层渲染编程接口，是针对iphone和ipad中的GPU高度优化的编程框架，是iOS平台中最接近底层硬件的图形框架。 视图和动画渲染过程渲染过程我们可以分成6个阶段： APP内部4个阶段：1. 布局：为图层准备层级关系，位置，颜色等等。 2. 创建BackingStore Image（寄宿图片）： 这个阶段如果需要的话，创建layer的backing image，可能是通过layer的Contents传入的，也可能是drawRect、drawLayer:inContext:方法画出来的。 3. 准备以及解压：这个阶段，Core Animation框架准备各种渲染需要的数据，解压需要显示的图片。 4. 提交：这个阶段Core Animation打包layer的所有信息，以及动画参数，通过IPC(进程内通讯)传递给Render Server。（此步骤递归，如果layerTree比较复杂，则开销较大）。 APP外部2个阶段：到达render Server后会转化为render Tree，进行下面的步骤： 5. 渲染前准备和计算：所有layer的属性，如果是动画，计算中间值，准备渲染。 6. 渲染：渲染到屏幕上。 这6个阶段中，前5个都是由CPU处理的，最后一个阶段才由GPU处理；我们能控制的只有前面两个阶段，剩下的工作由系统框架帮我们处理；如果是动画，最后两个步骤会一直重复，知道动画结束。 我们知道iOS设备的屏幕刷新率是60fps，如果没有在1/60s内结束这6个步骤就会掉帧视觉感受就是在卡。如下图： 所以，我们在动画性能调优方面的策略就是让CPU和GPU都可以在这1/60秒内做完他们应该做的事情，如果有卡顿，我们便要找出来是CPU负担太重，还是GPU负担太重，找到原因后相应的给他们减负。 绘制渲染相关优化耗费CPU的性能的项目 布局计算：当视图层级复杂，frame变化，需要复杂计算，会加重CPU的计算负担。例如：动态计算tableviewCell的高度，使用autolayout也会非常耗费计算CPU的性能。 图片的解压和转换：渲染前会解压压缩的图片，而且如果图片颜色格式不是32位的，那么CPU会进行颜色格式转换，所以，我们最好直接提供32位颜色格式的图片。 绘制需求：直接使用CaLayer进行绘制的话，当我们重写UIView的drawRect方法，或者是drawLayer方法，那么系统会创建layer的寄宿图，这种方式绘制会使得内存暴增。尽量避免，建议使用CAShapeLayer进行绘制，CAShapeLayer使用了硬件加速，渲染速度更快，内存使用非常稳定，不会被图层边界切割，也不会像素化。 隐藏的绘制：UILable的文字都是画到寄宿图片上的，如果改变frame，会重新绘制。 多层级视图：如果一个layer被另一个layer完全遮盖，GPU不会渲染被遮盖的视图，但是计算是否完全被遮盖，很消耗CPU资源 耗费GPU的性能的项目 图层混合overdraw：一个像素点被多次使用颜色填充，如果太多的话，肯定会影响GPU性能。如果一个视图是不透明的我们应该设置opaque为yes，主动告诉GPU。 离屏渲染Off-Screen Rendering：某些属性的设置，会出发离屏渲染，而离屏渲染会让GPU在当前屏幕缓冲区以外再开拓一个新的缓冲区，进行渲染操作，创建完新的缓冲区会进行上下文切换，切到新缓冲区，渲染完再切回来，把新缓冲区的结果带回来显示，这一切操作，都比较耗费GPU的资源。 关于优化的问题，我们日后再详细分析。","tags":[{"name":"UI","slug":"UI","permalink":"https://cxlhaha.github.io/tags/UI/"}]},{"title":"离屏渲染","date":"2018-11-13T07:53:06.000Z","path":"2018/11/13/离屏渲染/","text":"GPU渲染的两种方式： On-Screen Rendering(当前屏幕渲染)： GPU在用于显示的屏幕缓冲区进行渲染。 Off-Screen Rendering(离屏渲染)： GPU离开当前用于显示的屏幕缓冲区，重新创建一个屏幕缓冲区进行渲染，等待渲染结束后GPU回到用于显示的屏幕缓冲区，并将离屏渲染的结果拷贝回来。 离屏渲染的代价离屏渲染是一件代价很大的操作，非常消耗GPU性能，体现在以下两个方面： 创建新的屏幕缓冲区：想要离开当前用于显示的屏幕缓冲区，就要创建一个新的用于离屏渲染的屏幕缓冲区，而新的屏幕缓冲区的创建和销毁都比较耗费性能。 上下文切换：从当前用于显示的屏幕缓冲区切换到另一个屏幕缓冲区，渲染结束后又要切换回来，这样来回的切换操作，也是非常消耗性能的事情。 为什么要离屏渲染既然离屏渲染如此消耗GPU性能，那为什么还要进行离屏渲染？ 因为GPU认定某些效果过度复杂，无法在当前屏幕缓冲区直接渲染，需要在别的屏幕缓冲区进行预处理 会触发离屏渲染的情况圆角（RoundedCorner），阴影（Shawdow），遮罩（Mask），GroupOpacity等。 离屏渲染的优化根据不同的产生离屏渲染的原因，有不同的优化策略： 圆角： 最方便的是让设计师直接切一个圆角图片，这是最简单的。 图层混合：利用一张中间透明，圆角部分遮盖的图片，压在要显示的图片上。 阴影： 添加指定路径 12let path = UIBezierPath(rect: cell.imageView.bounds)imageViewLayer.shadowPath = path.CGPath//路径默认为 nil 如上代码添加一个简单的阴影路径便可以避免触发离屏渲染 图层混合，类似于圆角优化的图层混合，利用一张图片覆盖来达到效果 其它 iOS9之后UIImageView的圆角不会触发离屏渲染了，但是UIButton还会。 使用Core Graphics的绘制API也会产生一种特殊的离屏渲染（CPU版本的离屏渲染）。","tags":[{"name":"UI","slug":"UI","permalink":"https://cxlhaha.github.io/tags/UI/"}]},{"title":"iOS绘图","date":"2018-11-08T07:01:02.000Z","path":"2018/11/08/iOS绘图/","text":"前言当遇到绘图需求的时候我们就需要利用UIKit或者是CoreGraphics这两个绘图框架进行绘图，而这两个框架之间的关系是这样的： CoreGraphics是绘图方面的基础，它提供了大量的API满足我们各种各样的绘图需求，但是，因为CoreGraphics更加底层，是一套C语言的框架，所以，UIKit帮我们进行了封装，我们可以利用UIKit简洁的语法，快速的实现绝大多数的绘图需求。所以当绘图需求简单，我们想要快速实现时，我们可以利用UIKit进行绘图，而如果需要全部功能的绘图需求，我们就选择功能强大的CoreGraphics进行绘图。 UIKit只能在当前上下文中进行绘图，如果不是当前上下文需要转化为当前上下文再进行绘图。 如何绘图 因为我们需要在图形上下文上进行绘图，这里有两种常用的获取图形上下文的方式： 方式一：创建图片类型上下文 UIKit实现： 12345678910UIGraphicsBeginImageContext(CGSizeMake(200, 200)); [[UIColor greenColor] set]; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 200, 200)]; [path fill]; UIImageView *imgView = [[UIImageView alloc]initWithImage:UIGraphicsGetImageFromCurrentImageContext()]; imgView.frame = CGRectMake(100, 100, 200, 200); [self.view addSubview:imgView]; UIGraphicsEndImageContext(); CoreGraphics实现： 1234567891011UIGraphicsBeginImageContext(CGSizeMake(200, 200)); CGContextRef con = UIGraphicsGetCurrentContext(); CGContextAddEllipseInRect(con, CGRectMake(0, 0, 200, 200)); CGContextSetFillColorWithColor(con, [UIColor greenColor].CGColor); CGContextFillPath(con); UIImage *img = UIGraphicsGetImageFromCurrentImageContext(); UIImageView *imgView = [[UIImageView alloc]initWithImage:img]; imgView.frame = CGRectMake(0, 0, 200, 200); [self.view addSubview:imgView]; UIGraphicsEndImageContext(); 方式二：drawRect:方法获取图形上下文 UIKit实现： 123456-(void)drawRect:(CGRect)rect&#123; UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 200, 200)]; [path fill]; &#125; CoreGraphics实现： 1234567-(void)drawRect:(CGRect)rect&#123; CGContextRef con = UIGraphicsGetCurrentContext(); CGContextAddEllipseInRect(con, CGRectMake(0, 0, 200, 200)); CGContextFillPath(con); &#125; 性能问题值得注意的是，当我们进行绘图的时候，有时候会出现性能问题。比如说：当我们要实现一个画板功能时，我们首先想到的是重写drawRect方法，进行绘图，但是当画板足够大时，我们会发现，绘图时内存会暴增。这是因为，调用drawRect方法时，会生成系统会生成寄宿图，渲染前都会保存这张图片，当画板足够大时，就会导致内存暴增。当然有一些方法可以优化，我这里就不展开分析，我要说的是，最好的优化就是不去绘图，比如，那个画板需求，我们可以用CAShapeLayer实现，我们就会发现性能稳定多了，下面我就把两种实现的代码贴出来，有兴趣的同学自己尝试一下就会发现差别。 drawRect： 123456789101112131415161718192021222324-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; CGPoint point = [touches.anyObject locationInView:self]; UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:point]; [self.pathArray addObject:path];&#125;-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; CGPoint point = [touches.anyObject locationInView:self]; UIBezierPath *path = self.pathArray.lastObject; [path addLineToPoint:point]; [self setNeedsDisplay];&#125;-(void)drawRect:(CGRect)rect&#123; for (UIBezierPath *path in self.pathArray) &#123; [path stroke]; &#125;&#125; CAShapeLayer： 123456789101112131415161718192021222324- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; CGPoint point = [touches.anyObject locationInView:self]; UIBezierPath *path = [UIBezierPath bezierPath]; path.lineWidth = 5; [path moveToPoint:point]; self.lastPath = path; CAShapeLayer *sLayer = [CAShapeLayer layer]; sLayer.strokeColor = [UIColor blackColor].CGColor; sLayer.fillColor = [UIColor clearColor].CGColor; [self.layer addSublayer:sLayer]; &#125;-(void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; CGPoint point = [touches.anyObject locationInView:self]; [self.lastPath addLineToPoint:point]; CAShapeLayer *slayer= self.layer.sublayers.lastObject; slayer.path = self.lastPath.CGPath;&#125; 其它内容的绘图 文字绘制 123NSString *str = @\"fdfas\"; [str drawInRect:CGRectMake(100, 100, 100, 100) withAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:15],NSForegroundColorAttributeName:[UIColor greenColor]&#125;]; 图像绘制 123UIImage *image = [UIImage imageNamed:@\"121\"]; [image drawInRect:CGRectMake(0, 0, 100, 100)];","tags":[{"name":"UI","slug":"UI","permalink":"https://cxlhaha.github.io/tags/UI/"}]},{"title":"iOS绘图之贝塞尔曲线（UIBezierPath）","date":"2018-10-26T03:19:57.000Z","path":"2018/10/26/iOS绘图之贝塞尔曲线（UIBezierPath）/","text":"介绍UIBezierPath是UIKit对Core Graphics中关于path的一个封装，UIBezierPath提供给我们很多非常便捷的API，可以满足我们绝大多数对路径绘制的需求，利用UIBezierPath我们绝大多数情况下可以不用再去利用Core Graphics库中的C语言API去绘制路径。 所以当我们有绘制需求的时候，我们应该优先考虑UIBezierPath 上手练习我们先创建一个用于测试的UIView，并重写它的drawRect：方法： 绘制一个矩形： 12345-(void)drawRect:(CGRect)rect&#123; UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(30, 30, 100, 100)]; [path stroke]; &#125; 效果如下： 大家可以看到短短两行代码，我们就成功的绘制了一个矩形。 利用UIBezierPath的类方法，我们只需要传入一个CGRect就可以生成一个矩形贝塞尔曲线。 stroke方法则帮我们渲染这条曲线，我们可以形象的理解为为这个曲线描边。 类似的我们可以绘制其它图形。 绘制一个椭圆（或者是圆）： 12UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(30, 30, 200, 100)];[path stroke]; 这个API会绘制一个传入矩形的内切椭圆（圆）效果如下： 绘制一条弧线： 12UIBezierPath *path2 = [UIBezierPath bezierPathWithArcCenter:CGPointMake(200, 200) radius:100 startAngle:0 endAngle:M_PI_2 clockwise:YES];[path2 stroke]; 我们只需要传入这段弧线的圆心半径，开始结束角度，是否顺时针效果如下： 绘制一个自定义图形： 12345678UIBezierPath *path3 = [UIBezierPath bezierPath]; [path3 moveToPoint:CGPointMake(100, 100)]; [path3 addLineToPoint:CGPointMake(200, 100)]; [path3 addLineToPoint:CGPointMake(150, 100+50*sqrt(3))]; [path3 addArcWithCenter:CGPointMake(150, 100+50*sqrt(3)/3.0) radius:200*sqrt(3)/3.0 startAngle:M_PI_2 endAngle:M_PI*2/3.0+M_PI_2 clockwise:YES]; [path3 addLineToPoint:CGPointMake(100, 100)]; [path3 stroke]; 如果我们需要绘制的图形并不规则，我们可以通过一点点添加线段，弧线等操作绘制兹定于图形。 效果如下： 绘制二次贝塞尔曲线： 1234UIBezierPath *path4 = [UIBezierPath bezierPath]; [path4 moveToPoint:CGPointMake(100, 100)]; [path4 addQuadCurveToPoint:CGPointMake(200, 100) controlPoint:CGPointMake(180, 150)]; [path4 stroke]; 通过传入开始结束点和一个控制点，来绘制一个二次贝塞尔曲线，这个控制点同时是这条曲线在起点和终点的切线焦点 效果如下： 原理如下： 绘制三次贝塞尔曲线： 1234UIBezierPath *path5 = [UIBezierPath bezierPath]; [path5 moveToPoint:CGPointMake(50, 100)]; [path5 addCurveToPoint:CGPointMake(300, 100) controlPoint1:CGPointMake(100, 0) controlPoint2:CGPointMake(200, 200)]; [path5 stroke]; 通过传入开始结束点和两个控制点，来绘制一个三次贝塞尔曲线，第一个控制点和起点的连线是曲线在起点的切线，第二个控制点，和终点的连线是曲线在终点的切线 效果如下： 原理如下： 贝塞尔曲线的配置 填充（fill） 在图形的绘制中，UIBezierPath还提供给了我们很多其它参数去配置，我们挑一些重要的来分析。 首先，我们刚刚对贝塞尔曲线的绘制都是调用stroke方法，也就是描边，除了stroke方法还以一个fill方法，也就是填充 12UIBezierPath *path1 = [UIBezierPath bezierPathWithRect:CGRectMake(30, 30, 200, 100)];[path1 fill]; 效果如下： 设置颜色 我们还能给绘制的图形设置颜色： 123[[UIColor blueColor] set]; UIBezierPath *path1 = [UIBezierPath bezierPathWithRect:CGRectMake(30, 30, 200, 100)]; [path1 stroke]; 效果如下： 设置线条宽度 给描边的线条设置宽度： 123UIBezierPath *path1 = [UIBezierPath bezierPathWithRect:CGRectMake(30, 30, 200, 100)]; path1.lineWidth = 10; [path1 stroke]; 效果如下：","tags":[{"name":"UI","slug":"UI","permalink":"https://cxlhaha.github.io/tags/UI/"}]},{"title":"事件分发和响应者链条","date":"2018-10-19T10:06:54.000Z","path":"2018/10/19/事件分发和响应者链条/","text":"前言作为UI部分的第一篇文章，我决定写这篇关于事件分发，和响应者链条传递的过程的博文，因为这块知识是UI部分最基础的，但也是最容易让我们所忽视的，直到，当我们写页面时，发现我们认为该响应点击的控件并没有如我们想象，我们才发现自己对这一块知识我们其实并没有吃透，想当然的以为会按照看起来应该的方式响应。 简述区别事件分发和响应者链条，完完全全是两件事，两个过程，同学们不能把它混为一谈，虽然，先进行事件分发，然后再通过响应者链条查找到响应者，这两个过程加起来完成了一次对事件的处理，但它们绝不是一回事。 简单来说，这两个过程所做的事情： 事件分发：自上而下的由UIApplication开始，一路往最具体的View查找，直到找到最应该处理并且能够处理事件的那个控件。 响应者链条：当找到那个最应该处理并且能够处理事件的那个控件以后，如果这个控件确实处理了这个事件，那么这个事件的就到此处理完毕，但是很有可能出现的情况是，虽然这个控件最应该处理，也能够处理事件，但是它并没有处理事件，那么这时这个事件就要传给下一个响应者处理，下一个响应者还不处理，那就再下一个，这个事件就沿着这条响应者链条找直到响应者确实处理了这个事件（并中断了事件传递，就是在touch方法里没有调用下一个响应者的touch方法）为止 很重要的一点：事件的分发路径和响应者链条的路径并不是同一条路从两头走的关系。首先，事件分发时候除了最开始的UIApplication，一路都是在查找下一个更应该响应的UIView，而响应者链条除了考虑UIView以外还有其他的UIResponder,例如UIViewController；其次，事件分发会考虑同级UIView之间的关系，就是如果一个UIView有多个子View，那么哪个是更应该响应的View，而响应者链条则不会考虑同级View之间的关系，一个View的下一个响应者并不会考虑除了自己以为其它适合响应的同级View，而是之间考虑它的父View或者是控制器。 这就决定了这两个过程走的绝对不是同一条路（即使看起来有点像）。 事件分发当我们手指触摸屏幕时，系统会生成UITouch对象（一个手指一个UITouch），然后系统又会帮我们把所有的UITouch对象包装成一个UIEvent，然后把这个UIEvent交给UIApplication单例维护着的一个事件队列，当轮到这个事件处理的时候，UIApplication首先会将这个UIEvent交给KeyWindow，然后KeyWindow再交给它的根控制器的View，然后不断的递归寻找最适合处理这个事件的View。 这个递归查找的方法叫做hitTest 下面我们尝试的写一下这个方法的实现： 1234567891011121314151617181920212223242526272829-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123; //如果不能处理,返回nil if (self.hidden==YES||self.alpha&lt;=0.01||self.userInteractionEnabled == NO) &#123; return nil; &#125; //如果不应该处理返回nil if ([self pointInside:point withEvent:event]==NO) &#123; return nil; &#125; //找找看有没有更适合处理的子View //最后添加的(也就是最上面的View)先处理 NSArray *reverseArray = [[self.subviews reverseObjectEnumerator]allObjects]; for (UIView *subView in reverseArray) &#123; CGPoint subPoint = [self convertPoint:point toView:subView]; UIView *resultView = [subView hitTest:subPoint withEvent:event]; if (resultView) &#123; return resultView; &#125; &#125; //遍历完都没有子控件更适合,那么最适合的就是自己 return self;&#125; 响应者链条当找到这个最适合的控件后，会从这个控件开始尝试处理事件并传递给下一个响应者（直到某个响应者中断了传递）。 那么，怎么寻找下一个响应者呢？原则如下： 如果这个view是一个控制器的View那么这个View的下一个响应者就是控制器。 如果这个View不是控制器的View那么下一个响应者就是它的父View。 根控制器的下一个响应者是谁UIWindow，再下一个响应者是UIApplication，链条结束。 如果我们把A控制器的View添加到B控制器的View上，那么A控制器会在响应者链条上吗，如果在，它的下一个响应者是谁？ 如果要把A控制器添加到响应者链条，就要B控制器add A为子控制器，如果不add的话A控制器不会在这个响应者链条内，A控制器的下一个响应者为A控制器View的父View。","tags":[{"name":"UI","slug":"UI","permalink":"https://cxlhaha.github.io/tags/UI/"}]},{"title":"NSNotification 深入探究","date":"2018-10-18T07:41:45.000Z","path":"2018/10/18/NSNotification-深入探究/","text":"使用背景通常情况下，我们一个对象想要调用另外一个对象的方法，便是向这个对象传递消息，那么有个前提是，我们需要能找到这个对象，或者和这个对象有联系（这个对象传递给我一个block，或者是我的观察者等）。 那如果这响应消息的对象和我们当前对象并没有什么关系，处于两个独立的子系统，或者我们不知道它是谁，有几个对象需要相应这个消息，那么通知机制就应运而生，它就是为了处理这样的情况。 常规使用我们在最常用的通知使用方式中，一般为以下三个步骤： 1.添加通知的观察者和相应方法 12345[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(reciveNotification:) name:@\"test\" object:nil];-(void)reciveNotification:(NSNotification *)notification&#123; NSLog(@\"%@\",notification);&#125; 2.发送通知 1[[NSNotificationCenter defaultCenter] postNotificationName:@\"test\" object:nil userInfo:@&#123;@\"k\":@\"v\"&#125;]; 3.移除通知 1234-(void)dealloc&#123; [[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 相信这种常规用法，同学们经常使用，但是有几个注意点，我这里要提一下。 发送通知和接受通知ABI中的object参数，是通知发送者的意思。如果添加观察者的时候指定了object，也就是指定了发送者，那么只接受这个发送者发送的通知。如果发送通知时没有指定发送者或者指定了其它发送者，那么不会接受响应这个通知。如果添加观察者时没有指定发送者object，那么，任何发送者发送的通知，只要name匹配就都会响应。 关于移除通知，早在iOS8以及iOS8之前，如果不在dealloc时候移除观察者的话，当该通知再次发送时，会因为bad_access(野指针错误)而崩溃，因为当时通知中心持有的观察者被修饰为unsafe_unretained，当观察者被销毁后就会指向一块空白的内存区域，当通知中心对这个对象发送消息时，就会野指针错误而崩溃；而在iOS9以后，当observe将要被释放时，系统帮助我们判断，如果我们没有移除观察者的话，则系统帮助我们移除观察者。并且，在iOS9以后，通知中心保存的观察者被修饰为weak，当观察者被销毁后，该指针指向nil，我们知道，对nil发送消息是不会有任何问题的，只是，也没有任何效果而已。 多线程相关我们编写如下代码： 123456789101112//发送dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_global_queue(0, 0), ^&#123; NSLog(@\"willSent ---- %@\",[NSThread currentThread]); [[NSNotificationCenter defaultCenter] postNotificationName:@\"test\" object:nil userInfo:@&#123;@\"k\":@\"v\"&#125;]; NSLog(@\"sent ---- %@\",[NSThread currentThread]); &#125;); //接收 -(void)reciveNotification:(NSNotification *)notification&#123; sleep(3); NSLog(@\"%@---%@\",notification,[NSThread currentThread]);&#125; 控制台打印如下： 123452018-10-18 14:08:14.934069+0800 NSNotificationTest[70998:5916452] willSent ---- &lt;NSThread: 0x600001648e00&gt;&#123;number = 3, name = (null)&#125;2018-10-18 14:08:17.934687+0800 NSNotificationTest[70998:5916452] NSConcreteNotification 0x600000d40930 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x600001648e00&gt;&#123;number = 3, name = (null)&#125;2018-10-18 14:08:17.934870+0800 NSNotificationTest[70998:5916452] sent ---- &lt;NSThread: 0x600001648e00&gt;&#123;number = 3, name = (null)&#125; 通过以上的简单的测试代码，我们可以得到以下结论： 发送通知和接受通知时响应通知的方法总是在同一个线程。 所以通知是会阻塞当前线程，当响应通知的方法处理完以后，代码才会继续执行。 多次添加的观察者如果我们重复多次添加观察者，那么通知的响应方法会多次调用： 123for (int i = 0; i&lt;10; i++) &#123; [[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(reciveNotification:) name:@\"test\" object:nil]; &#125; 控制台： 123456789101112131415161718192021222324252627282930312018-10-18 15:18:01.744625+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.745118+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.745414+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.745580+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.745725+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.745874+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.746025+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.746175+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.746391+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.750810+0800 NSNotificationTest[71756:5954522] NSConcreteNotification 0x6000038101e0 &#123;name = test; userInfo = &#123; k = v;&#125;&#125;---&lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125;2018-10-18 15:18:01.750928+0800 NSNotificationTest[71756:5954522] sent ---- &lt;NSThread: 0x6000023593c0&gt;&#123;number = 1, name = main&#125; block形式添加观察者在通知中心中，我们还有一个以block形式响应通知的ABI： 123self.observer = [[NSNotificationCenter defaultCenter]addObserverForName:@\"test\" object:nil queue:nil usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@\"useBlock\"); &#125;]; 别的参数不做说明，这个方法返回添加的观察者由系统分发，我们应该保留下来，以便移除该观察者，如果我们不主动移除它并不能像控制器，在销毁的时候我们系统帮我们移除控制器这个观察者,从而会造成内存泄露。","tags":[{"name":"OC","slug":"OC","permalink":"https://cxlhaha.github.io/tags/OC/"}]},{"title":"分类（category）和类扩展（extension）","date":"2018-10-10T10:51:20.000Z","path":"2018/10/10/分类（category）和类扩展（extension）/","text":"分类（category）应用场景在我们开发中经常会有这样的问题： 多个人同时维护同一个类 ，彼此之间交叉修改同一个文件，导致冲突以及文件臃肿。 想给已经封装好的类（或者是系统类，第三方库的类）增加方法，而又不想使用继承后的子类。 希望拆分一个过于庞大的类。 分类（category）可以很好的解决这些问题。 介绍分类是OC的一种语法，他可以在一个新的文件中为一个即有的类添加新的方法（理论上不能添加新的属性） 我们为NSObject添加一个分类名为haha的分类,并在这个分类中为NSObject添加一个laugh方法： 123456789101112131415161718.h@interface NSObject (haha)-(void)laugh;@end.m#import \"NSObject+haha.h\"@implementation NSObject (haha)-(void)laugh&#123; NSLog(@\"hahahahahaha\");&#125;@end 在程序入口处，我们只需要引用这个分类，就可以直接调用分类里的方法了： 1234#import \"NSObject+haha.h\"NSObject * obj = [NSObject new];[obj laugh]; 源码分析我们在runtime.h中可以找到category的运行时结构体： 1234567struct objc_category &#123; char * _Nonnull category_name OBJC2_UNAVAILABLE; char * _Nonnull class_name OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable instance_methods OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable class_methods OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;&#125; 我们可以看到，在运行时，分类的结构体里有分类名，原类名，实例方法列表，类方法列表，协议列表。但是并没有变量列表。 这就是分类中是无法添加变量的原因。 如果非要为分类添加属性，我们可以用动态添加属性（Associated Object）技术间接实现 我们在haha分类中为NSObject添加一个name属性： 12345678.h@interface NSObject (haha)@property(nonatomic,copy)NSString *name;-(void)laugh;@end 这时在.m文件中系统给我们警告，让我们实现name方法和setName方法，因为，在分类中定义属性，系统并不会为我们生成get，set方法，也不会生成实例变量。 我们需要利用动态添加属性（Associated Object）手动编写get和set方法： 123456789101112131415161718192021#import \"NSObject+haha.h\"#import &lt;objc/runtime.h&gt;static NSString *nameKey = @\"nameKey\";@implementation NSObject (haha)-(void)laugh&#123; NSLog(@\"hahahahahaha\");&#125;-(NSString *)name&#123; return objc_getAssociatedObject(self, &amp;nameKey);&#125;-(void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, &amp;nameKey, name, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125; 通过这种方式，我们看起来就为分类添加了一个name属性,但是任然不能访问_name实例变量，因为它并不存在。 小细节 分类中可以使用原类的.h中的属性，方法。 如果分类中有原类的同名方法，那么，会覆盖原类方法。同名方法优先级：分类&gt;原类&gt;父类 如果多个分类有同名方法，那么执行最后加入编译的分类的方法。 类扩展（Class Extension）类扩展介绍类扩展其实我们平时使用非常多，只是可能很多同学不知道，那个就是类扩展而已，我们平时创建控制器时IDE就会帮我们在.m文件里自动生成一个类扩展，供我们写一些私有的方法和属性： 123@interface ViewController ()@end 类扩展最常见的使用场景就是在.m中定义私有的属性和方法。 类扩展的几个特点 与分类不同的是类扩展是可以添加属性的，并且会自动生成get方法，set方法，实例变量。 类扩展可以定义在.m 中，其中的属性方法为私有，也可以定义在.h中，它的属性和方法为共有。 类扩展的中方法的实现，必须在原类的.m文件中。","tags":[{"name":"OC","slug":"OC","permalink":"https://cxlhaha.github.io/tags/OC/"}]},{"title":"KVO","date":"2018-10-09T06:32:15.000Z","path":"2018/10/09/KVO/","text":"今天和大家讨论一下OC中KVO（KeyValueObserving）键值观察 KVO定义KVO是iOS开发中的一套事件通知机制，它允许OC对象对另一个对象的属性进行监听，而不需要在被监听的对象中插入任何代码，是iOS开发实现观察者模式的一种方式。KVO不仅可以监听某个单一属性，也可以监听集合属性，例如NSArray，NSSet。它们内部结构发生改变时也能接收到通知。 观察者模式，就是被观测的对象属性发生改变时，主动通知观察者，通过观察者模式可以很好的将观察者和被观察者解耦。 KVO原理KVC和KVO的底层机制都是isa-swizzling，在我们使用KVO时，底层会在运行时动态的创建一个新类，这个类是被观察对象类的子类，这个新类会重写原类的set方法，在set方法中对观察者进行通知，也会重写class方法，返回的class依然是原类，通过这样伪装成原类。然后篡改被观察对象的isa指针，让他指向新类。这样，这个被观察的对象就变成新类的对象了，将会在set方法通知观察者。所以我们平时不应该依赖isa确定类的继承关系，而应该使用class方法。 下面我们用代码来验证：我们建立一个Person类， 1234567@interface Person : NSObject@property (nonatomic,copy)NSString *name;@property (nonatomic,strong)NSMutableArray *friends;@end 我们重写它的description方法 12345678910111213141516171819202122232425-(NSString *)description&#123; NSString *des = @\"\"; des = [des stringByAppendingString:[NSString stringWithFormat:@\"\\nobject address :%p\\n\",self]]; IMP setNameImp =class_getMethodImplementation(object_getClass(self), @selector(setName:)); des = [des stringByAppendingString:[NSString stringWithFormat:@\"setName IMP :%p\\n\",setNameImp]]; IMP setFriendImp = class_getMethodImplementation(object_getClass(self), @selector(setFriends:)); des = [des stringByAppendingString:[NSString stringWithFormat:@\"setFriends IMP :%p\\n\",setFriendImp]]; Class methodClass = [self class]; des = [des stringByAppendingString:[NSString stringWithFormat:@\"methodClass :%@\\n\",methodClass]]; Class runtimeClass = object_getClass(self); des = [des stringByAppendingString:[NSString stringWithFormat:@\"runtimeClass :%@\\n\",runtimeClass]]; Class superClass = class_getSuperclass(runtimeClass); des = [des stringByAppendingString:[NSString stringWithFormat:@\"superClass :%@\\n\",superClass]]; des = [des stringByAppendingString:@\"methodList:\\n\"]; int count ; Method* methodList = class_copyMethodList(runtimeClass, &amp;count); for (int i = 0; i&lt;count; i++) &#123; Method method = methodList[i]; NSString *methodName= NSStringFromSelector(method_getName(method)) ; des = [des stringByAppendingString:[NSString stringWithFormat:@\"methodName:%@\\n\",methodName]]; &#125; return des;&#125; 在程序入口处我们新建一个Person实例，在注册观察者前后分别输出 1234567Person *zhangsan = [Person new]; NSLog(@\"before%@\",zhangsan); [zhangsan addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionPrior|NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil]; NSLog(@\"after%@\",zhangsan); 控制台打印如下： 1234567891011121314151617181920212223242526272018-10-08 18:35:59.811813+0800 KVOTest[18443:3966395] beforeobject address :0x6000031e8740setName IMP :0x104c0e410setFriends IMP :0x104c0e470methodClass :PersonruntimeClass :PersonsuperClass :NSObjectmethodList:methodName:setFriends:methodName:friendsmethodName:.cxx_destructmethodName:descriptionmethodName:namemethodName:setName:2018-10-08 18:35:59.812222+0800 KVOTest[18443:3966395] afterobject address :0x6000031e8740setName IMP :0x104f6790asetFriends IMP :0x104c0e470methodClass :PersonruntimeClass :NSKVONotifying_PersonsuperClass :PersonmethodList:methodName:setName:methodName:classmethodName:deallocmethodName:_isKVOA 我们可以看到在注册观察者后，运行时的类由Person变成了NSKVONotifying_Person，name的set方法被重写了，父类由NSObject变成了Person，delloc也被重写了，系统在delloc中释放一些资源 KVO用法1. 添加观察者 首先需要注册观察者： 1[zhangsan addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionInitial|NSKeyValueObservingOptionPrior|NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil]; options参数和kvc的options意义相同 NSKeyValueObservingOptionPrior为值改变前也触发一次通知。 NSKeyValueObservingOptionInitial为刚注册后就触发一次通知。 NSKeyValueObservingOptionNew通知新值。 NSKeyValueObservingOptionOld通知旧值。 2. 添加监听方法 在监听方法里写接收到被观察者改变后的业务逻辑 1234-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;&#125; 3. 移除观察者 1234-(void)dealloc&#123; [self.testP removeObserver:self forKeyPath:@\"name\"];&#125; 值得注意的是，添加观察者和移除观察者是成对儿出现的，多次移除或者不移除都会导致crash。 对集合对象的观察kvo不光可以对某个具体对象观察，对集合对象也可以观察，我们以NSArray为例 12345Person *zhangsan = [Person new]; Person *lisi = [Person new]; Person *wangwu = [Person new]; zhangsan.friends = [@[lisi ,wangwu] mutableCopy]; 我们希望张三的friends变化时我们可以接受到通知。 1[zhangsan addObserver:self forKeyPath:@\"friends\" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld|NSKeyValueObservingOptionPrior|NSKeyValueObservingOptionInitial context:NULL]; 添加观察者，这并没有什么不同。 1[[zhangsan mutableArrayValueForKey:@\"friends\"] addObject:[Person new]]; 这个是重点，如果希望接收到通知，我们不能使用zhangsan.friends来获取数组，而要用kvc的方式来获取可变数组。这样当friends内部结构改变时便可以触发通知。 KVO自动通知和手动通知kvo注册观察者后默认在被观察属性变化后主动通知，而如果你希望手动控制这个过程则可以如下处理 12345678910-(void)setName:(NSString *)name&#123; [self willChangeValueForKey:@\"name\"]; _name = name; [self didChangeValueForKey:@\"name\"];&#125;+(BOOL)automaticallyNotifiesObserversOfName&#123; return NO;&#125; 我们一般不会这样做，除非你想精确控制这个过程。 KVO问题以及解决方案kvo本身存在一些问题，例如：使用不当容易造成crash，不支持block，需要手动移除观察者较为繁琐等，一些第三方的库很好的解决了这些问题例如：KVOController等。","tags":[{"name":"OC","slug":"OC","permalink":"https://cxlhaha.github.io/tags/OC/"}]},{"title":"KVC","date":"2018-09-30T03:31:03.000Z","path":"2018/09/30/KVC/","text":"今天和大家讨论一下OC中KVC（KeyValueCoding）键值编码 KVC定义KVC（KeyValueCoding）键值编码技术可以让我们在OC的开发中使用字符串作为Key来访问某个对象的属性值或者为某个对象的属性值进行赋值。而不需要通过暴露在头文件中的存取器方法进行访问和赋值操作。通过这种方法，我们可以获取某个对象并没有暴露在头文件中的实例变量和为这个实例变量进行赋值操作。通过这种方法可以绕过编译器的审查，使我们能够做出一些”不太合规“的操作，而不会让编译器报错。因此这种形式的存取是在运行时进行的，也是OC动态特性的一种体现。 KVC原理NSObject有个分类（NSKeyValueCoding）关于KVC的实现都在里面，所以，所有继承自NSObject的对象都可以使用KVC，而结构体和某些Swift对象因为没有继承NSObject而不可以使用 KVC取值设值以及查找顺序KVC进行取值和设值操作时会根据你所传递的字符串按照一定规律进行查找，我们编写代码进行测试，以找到这个规律。首先我们新建一个Person类 取值 在我们程序入口利用KVC来获取Person示例的name属性 12Person *zhangSan = [Person new]; NSLog(@\"%@\",[zhangSan valueForKey:@\"name\"]); 在Person.m编写代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#import \"Person.h\"@interface Person ()&#123; NSString *_name;//第一个查找的实例变量 NSString *_isName;//第二个查找的实例变量 NSString *name;//第三个查找的实例变量 NSString *isName;//第四个查找的实例变量 &#125;@end@implementation Person- (instancetype)init&#123; self = [super init]; if (self) &#123; _name = @\"ivar _name\"; _isName = @\"ivar _isName\"; name = @\"ivar name\"; isName = @\"ivar isName\"; &#125; return self;&#125;//第一个取值查找的方法-(NSString *)getName&#123; return @\"getName method\";&#125;//第二个取值查找的方法-(NSString *)name&#123; return @\"name method\";&#125;//第三个取值查找的方法-(NSString *)isName&#123; return @\"isName method\";&#125;//第四个取值查找的方法-(NSString *)_name&#123; return @\"_name method\";&#125;//当成数组处理-(NSInteger)countOfName&#123; return 2;&#125;-(id)objectInNameAtIndex:(NSInteger)index&#123; return @\"数组成员\";&#125;//是否可以直接操作实例变量，默认返回yes+(BOOL)accessInstanceVariablesDirectly&#123; NSLog(@\"accessInstanceVariablesDirectly\"); return YES;&#125;@end 经过代码测试我们发现，当我们对Person的示例使用KVC来获取它的name属性时，系统先会按照顺序查找一系列方法是否存在如果存在便调用并拿到这个方法的返回值作为kvc取值的结果，这一系列的方法的顺序便是我上文代码中注释的顺序，分别是getName name isName _name,如果第一个方法就存在那便不再调用之后的方法，以此类推。 当四个方法全都没有找到时，我们的系统会把name当做数组去处理，看看是否实现了代码中的两个方法。如果实现了，就返回一个数组。 如果数组方法也没有找到，会当做集合去处理，在实现中查找相应的方法。 如果集合的相关方法也没有找到，系统会调用accessInstanceVariablesDirectly方法，这个方法是指示是否允许直接操作示例变量的，如果你没有重写这个方法，默认返回是yes。如果返回NO则程序不再往下执行，崩溃，如果返回yes，那么将会按照顺序查找相应的示例变量，他们的顺序是：_name _isName name isName;如果有对应的实例变量那就返回他的值，如果四个都查找不到，那么程序崩溃。 赋值 赋值的方式和取值的方式类似也是先按顺序查找方法，如果方法都没有查找到，那么调用accessInstanceVariablesDirectly方法，如果返回yes则会按照同样的顺序查找相应的实例变量 在程序入口处： 12Person *zhangSan = [Person new]; [zhangSan setValue:@\"2341\" forKey:@\"name\"]; 在Person.m编写代码如下： 12345678910//第一个查找的方法-(void)setName:(NSString *)name&#123; NSLog(@\"setName %@\",name);&#125;//第二个查找的方法-(void)_setName:(NSString *)name&#123; NSLog(@\"_setName %@\",name);&#125; keypath在KVC中还可以使用keypath路径来访问属性举例说明：就刚刚的Person类我们给它创建一个lover属性，lover的类型也是Person那么我们想要获取某个Person对象的lover的name我们要怎么做呢？我们可以这样 12Person *zhangSan = [Person new]; [zhangSan valueForKeyPath:@\"lover.name\"]; KVC允许我们使用.来连接属性这样我们可以方便的获取对象的属性的属性。。。 避免崩溃正常情况下如果我们把nil设置给一个非对象属性，或者查找一个并不存在的key程序就会崩溃，我们通过重写下面的这些方法可以避免崩溃 123456789101112131415-(void)setNilValueForKey:(NSString *)key&#123; NSLog(@\"不允许设置为nil\");&#125;-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; NSLog(@\"不存在这个key\");&#125;-(id)valueForUndefinedKey:(NSString *)key&#123; NSLog(@\"不存在这个key\"); return nil;&#125; 数字和结构体当属性类型为数字或者结构体时，我们不能直接用数字和结构体来赋值，而是需要转化为NSNumber和NSValue来赋值，同样的，我们获取到的值也会被转化为NSNumber和NSValue类型。 数组的KVC应用在数组中KVC有一些特有的运算符，我们一起看一下用法吧我们编写代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142 Person *zhangsan = [Person new]; [zhangsan setValue:@10 forKey:@\"age\"]; Person *lisi = [Person new]; [lisi setValue:@20 forKey:@\"age\"]; Person *wangwu = [Person new]; [wangwu setValue:@30 forKey:@\"age\"]; Person *zhaoliu = [Person new]; [zhaoliu setValue:@10 forKey:@\"age\"]; NSArray *peoples = @[zhangsan,lisi,wangwu,zhaoliu]; NSLog(@\"%ld\",((NSNumber*)[peoples valueForKeyPath:@\"@min.age\"]).integerValue) ; NSLog(@\"%ld\",((NSNumber*)[peoples valueForKeyPath:@\"@max.age\"]).integerValue) ; NSLog(@\"%ld\",((NSNumber*)[peoples valueForKeyPath:@\"@sum.age\"]).integerValue) ; NSLog(@\"%ld\",((NSNumber*)[peoples valueForKeyPath:@\"@avg.age\"]).integerValue) ; NSLog(@\"%ld\",((NSNumber*)[peoples valueForKeyPath:@\"@count\"]).integerValue) ; NSLog(@\"%@\",[peoples valueForKeyPath:@\"@distinctUnionOfObjects.age\"]); NSLog(@\"%@\",[peoples valueForKeyPath:@\"@unionOfObjects.age\"]); ``` 输出结果为```objc2018-09-29 16:57:49.628811+0800 KvcKvoTest[254:3290335] 102018-09-29 16:57:49.628903+0800 KvcKvoTest[254:3290335] 302018-09-29 16:57:49.629141+0800 KvcKvoTest[254:3290335] 702018-09-29 16:57:49.629283+0800 KvcKvoTest[254:3290335] 172018-09-29 16:57:49.629370+0800 KvcKvoTest[254:3290335] 42018-09-29 16:57:49.629520+0800 KvcKvoTest[254:3290335] ( 10, 20, 30)2018-09-29 16:57:49.629647+0800 KvcKvoTest[254:3290335] ( 10, 20, 30, 10) 前面的五种运算符相信大家都可以明白它的用法，后面的两个运算符distinctUnionOfObjects为将数组中的对应属性排序去重返回一个数组，unionOfObjects为将数组中的对应属性返回一个数组。 字典的KVC应用字典也可以像普通对象一样使用kvc，因此valueForKeyPath可以很方便的用来操作多层字典。 还有两个方法用来字典转对象和对象转字典： 对象转字典： 123456Person *zhangsan = [Person new]; [zhangsan setValue:@10 forKey:@\"age\"]; [zhangsan setValue:@\"zhangsan\" forKey:@\"name\"]; NSDictionary *dic= [zhangsan dictionaryWithValuesForKeys:@[@\"age\",@\"name\"]]; NSLog(@\"%@\",dic); 字典转对象： 12Person *zhangsan = [Person new]; [zhangsan setValuesForKeysWithDictionary:@&#123;@\"name\":@\"zhangsan\",@\"age\":@10&#125;]; KVC用途总结使用KVC可以动态的取值，赋值，可以操作私有变量，可以修改一些系统控件，可以对数组进行一些操作，以及对象和字典的转换。和所有OC的动态特性一样，如果滥用会容易导致崩溃和一些不好排查的问题出现。","tags":[{"name":"OC","slug":"OC","permalink":"https://cxlhaha.github.io/tags/OC/"}]},{"title":"GCD技术","date":"2017-04-07T07:13:37.000Z","path":"2017/04/07/GCD技术/","text":"初识GCD在我们平时的OC开发中经常需要用到多线程编程,而GCD这项技术是最受开发者喜爱的多线程技术,我们今天就一起来学习这门技术. GCD可以说是一项划时代的技术,它用非常简单的语法,实现了非常复杂的多线程编程. 使用GCD,我们只需要把需要执行的任务追加到合适的队列Dispatch Queue中,GCD就能够生成适当的线程去执行任务 而GCD是一项非常底层的技术,苹果公司为我们做了大量的优化,所以我们才能如此优雅的进行多线程编程 GCD中最重要的概念一:队列在GCD中大致可以分为两种队列:Serial Dispatch Queue(串行队列)和Concurrent Dispatch Queue(并行队列) 苹果对GCD技术的使用指南上告诉我们:我们只需要把需要执行的任务追加到合适的队列中,GCD就会自动为我们生成并分配适当的线程去执行任务 既然是这样,那我们对于这两种队列特点的理解,就尤为重要了,只有选对追加的队列,我们才能达到想要的效果. Serial Dispatch Queue(串行队列):队列中的任务会按顺序分配到线程并执行,但是只有上一个任务执行完毕后,才会分配下一个任务并执行,所以串行队列同一时间只能执行一个任务,所以同一时间也只需要一个线程,任务会一个一个按顺序的执行完毕.具体某个具体任务的线程是当前线程还是GCD为我们创建的其它线程,则要取决于该任务的调用方式,是同步调用,还是异步调用 Concurrent Dispatch Queue(并行队列):并行队列,队列中的任务也会按顺序分配执行,但是与串行队列不同的是,不需要等待当前任务执行完毕,才分配下一个任务,可以在当前任务执行时分配下一个任务(如果下一个任务可以分配到与当前任务不同的线程而且该线程空闲),直到可利用的线程都有正在执行的任务,便会等待某一线程执行完毕,继续给该线程分配任务,但是当分配到不同线程同时执行时,任务执行完的顺序就不可控了,执行完的顺序一般不会和追加任务到队列的顺序一致,适用于不关心执行顺序的任务.如果该任务要求使用不同于当前线程的线程执行,那么并行队列可同时利用起多条线程,分配子线程的数量和分配给哪些子线程,是由GCD底层根据系统状态,CPU型号等等因素决定的,GCD会帮助我们开启恰到好处的线程数量,开发者不需要关心. 上面的这两种队列是我们GCD中的两种队列类型,这两种队列都可以使用相关函数进行创建; 1234//创建一个串行队列dispatch_queue_t serialQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL);//创建一个并行队列dispatch_queue_t conCurrentQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_CONCURRENT); 系统提供的几种特殊队列: Main Dispatch Queue(系统主队列):这个队列是系统创建的一个特殊的串行队列,说它特殊,是因为它队列里的任务只能在系统主线程执行,无论是同步调用还是异步调用这个队列中的任务,也不会改变它是在主线程里执行的事实.值得注意的是如果在主线程下在主队列中追加同步任务,会导致死锁,至于死锁的原因,我们下面对同步调用这种方式进行研究的时候再讨论.这个队列也是我们平时编码是默认的队列,我们的UI操作通常都在这个队列中 Global Dispatch Queue(系统全局队列):这个队列是系统生成提供给我们的一个并发队列,这个队列我们可以很方便的拿来使用,省去自己创建并发队列的繁琐.而且全局队列有四个优先级,其实对应的是四个全局队列,优先级分别是:high,default,low,background,我们应该把需要追加到队列里的任务追加到合适的全局队列中.如果我们创建的队列想要设定优先级,一般也会以这四个全局队列为参考,设置该队列与某全局队列优先级一致,具体函数,我们再下文中继续讨论. GCD中最重要的概念二:任务的同步异步首先,GCD中同步和异步的概念是相对于任务而言的,并不是对队列而言的,大家可以理解为任务的一个属性,开发者把某个任务追加到队列中时,会声明这个任务调用的方式,一个队列中即可以有同步调用的任务,也可以有异步调用的任务,他们都会按照顺序被分配,只是根据每个任务声明的调用方式不同,分配到不同的线程去执行.我们来看一看具体的区别吧. 异步调用:追加异步调用的任务到某个队列中.意思是当队列分配这个任务时,这个任务需要在非当前线程执行也就是子线程执行(主队列中的任务除外,主队列中的所有任务都只能在主线程执行,无论同步调用还是异步调用),当串行队列分配异步任务时,由于需要等到当前任务执行完毕时再执行下一任务,所以无论串行队列中有多少异步任务,也额外只需要一条子线程就可以,该子线程执行完毕当前任务,再执行下一个任务.速度比较慢.当并行队列分配异步任务时因为不需要等待当前任务执行完,所以可以在当前任务执行时,分配下一个异步任务到其它子线程,直到所有可利用的子线程都被分配了任务且正在执行任务,当一旦有这些子线程空闲,并行队列就会继续往这些空闲的队列中分配下一个任务.很明显如果有大量异步任务,则追加到并行队列处理速度更快,但是执行完毕的顺序却不可控,追加到串行队列的异步任务速度虽慢一些顺序却完全可控,大家可根据具体业务情况去选择. 我们看一下GCD中追加一个异步任务的API: 123456789dispatch_async(conCurrentQueue, ^&#123; for (int i=0; i&lt;10000; i++)&#123; NSLog(@\"do some thing%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"do other thing%@\",[NSThread currentThread]); 这个API除了把所要执行的该任务标记为异步调用追加到相应队列外,它还有如下特性:它只负责追加任务到队列,并不关心该任务是否执行,追加完后就会继续执行接下来的代码,至于任务执行则让队列自行安排. 所以我们控制台的打印会如下: 1234567892017-04-08 15:30:04.886 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;2017-04-08 15:30:04.886 GCDTest[1498:690846] do other thing&lt;NSThread: 0x600000076a00&gt;&#123;number = 1, name = main&#125;2017-04-08 15:30:04.887 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;2017-04-08 15:30:04.887 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;2017-04-08 15:30:04.887 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;2017-04-08 15:30:04.887 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;2017-04-08 15:30:04.888 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;2017-04-08 15:30:04.888 GCDTest[1498:690881] do some thing&lt;NSThread: 0x600000264640&gt;&#123;number = 3, name = (null)&#125;... 我们可以看到,在第二行就输出了do other thing并没有等到加载到队列中的任务执行完毕才继续往下执行. 同步调用:当该任务时同步调用时,分配该任务的队列会将任务分配到当前线程执行,所以无论是串行队列还是并行队列,都得等到当前线程执行的任务执行完之后才能分配队列中的下一个任务,所以看起来都是在当前线程一个一个执行的,但是主队列的任务还是只会在主线程执行. 我们看一下向队列中追加一个同步任务的API: 123456789dispatch_sync(conCurrentQueue, ^&#123; for (int i=0; i&lt;10000; i++)&#123; NSLog(@\"do some thing%@\",[NSThread currentThread]); &#125; &#125;); NSLog(@\"do other thing%@\",[NSThread currentThread]); 在语法上与追加异步任务只是方法名不一样,而在效果上,这段代码和异步追加任务的结果大不一样,以下是控制台的打印: 12345678910...2017-04-08 17:29:12.454 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.454 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.454 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.455 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.455 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.455 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.455 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.456 GCDTest[1745:969597] do some thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125;2017-04-08 17:29:12.456 GCDTest[1745:969597] do other thing&lt;NSThread: 0x608000263b00&gt;&#123;number = 1, name = main&#125; 大家可以看到,当所有同步追加到队列中的任务执行完毕后才会执行接下来的代码,在最后才输出了do other thing,这便是这两个API除了追加任务的属性不同外最大的区别,这个API会一直等到追加过的任务执行结束. dispatch_sync意义在哪里有的同学看到这里就会有个巨大的疑问,dispatch_sync同步调用的任务,并不会开启子线程在子线程执行,那这种方式有什么意义呢?为什么不直接写任务代码就好了,为什么还要放到队列里,同步调用? 有的时候我们会需要保证任务执行的次序,比如,我们有n个任务需要执行,这n个任务中,既有同步调用的任务,也有异步调用的任务,现在有第n+1个任务需要在当前线程执行,而且要保证前面的n个任务已经执行完毕,那么这个时候,就需要我们将这个第n+1个任务放到一个串行队列的尾部,来保证它在最后运行. dispatch_sync的等待会阻塞当前线程,这是我们大家要注意的.如果阻塞主线程会引起UI交互的卡顿.如果是在子线程,则不会有对交互有影响,只是它后面的代码需要等待它执行完毕. 下面的两段代码就是dispatch_sync和直接代码的对比,大家运行一下,就可以看出差别.使用dispatch_sync: 1234567891011121314for (int i=0; i&lt;10; i++) &#123; dispatch_async(serialQueue, ^&#123; sleep(1.0); NSLog(@\"do some thing%@\",[NSThread currentThread]); &#125;); &#125; dispatch_sync(serialQueue, ^&#123; NSLog(@\"do other thing%@\",[NSThread currentThread]); &#125;); 不使用dispatch_sync: 1234567891011for (int i=0; i&lt;10; i++) &#123; dispatch_async(serialQueue, ^&#123; sleep(1.0); NSLog(@\"do some thing%@\",[NSThread currentThread]); &#125;); &#125; NSLog(@\"do other thing%@\",[NSThread currentThread]); dispatch_sync串行队列死锁问题在我们追加同步任务到串行队列中时,如果使用不当,将有可能导致死锁的问题.为了避免这种情况的发生,我们要先来分析一下产生死锁的原因. 产生死锁的情况:”追加某个同步任务”这个任务,和追加的同步任务都追加在同一条串行队列中 原因分析:我们知道dispatch_sync追加同步任务这个函数将会等待追加的任务执行完毕才会结束,那么执行到这里时将会产生这样的情况: “追加同步任务”这个任务需要等待追加的同步任务执行完毕后才能结束 而这个同步任务所在的串行队列则需要等待位于队列前面的”追加同步任务”这个任务执行结束,才开始执行这个同步任务 所以这就造成了一个互相等待的局面,将会导致死锁程序崩溃,我们要全力避免这种情况的发生.最容易犯的错误是在主队列中向主队列添加同步任务.这便满足了上述构成死锁的条件,我们要切忌犯此错误. GCD其它常用APIdispatch_queue_create创建队列这个函数是创建GCD的队列所用的函数,这个函数可以生成串行队列和并行队列; 12345//生成串行队列dispatch_queue_t serialQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL); //生成并行队列 dispatch_queue_t conCurrentQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_CONCURRENT); 第一个参数用来表示这个队列,相当于队列名字,在用instrument调试或者产生崩溃日志时可以用的到.第二个参数用来表示是串行队列还是并行队列. dispatch_set_target_queue设定优先级这个函数有两个功能: 可以将某个队列的优先级指定为和另一个队列一致 12//制定queue1的优先级与高优先级全局队列一致 dispatch_set_target_queue(queue1, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)); 将某几个串行队列指定到另一个串行队列,大家可以理解为将几个串行队列合并成了一个串行队列,几个串行队列里的任务将不会同时执行 12345678910111213141516171819202122232425dispatch_queue_t serialQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL); dispatch_queue_t serialQueue2= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL); dispatch_queue_t serialQueue3= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_SERIAL); dispatch_set_target_queue(serialQueue, serialQueue3); dispatch_set_target_queue(serialQueue2, serialQueue3); for (int i=0; i&lt;10; i++) &#123; dispatch_async(serialQueue, ^&#123; sleep(1.5); NSLog(@\"%@\",[NSThread currentThread]); &#125;); &#125; for (int i=0; i&lt;10; i++) &#123; dispatch_async(serialQueue2, ^&#123; sleep(1.5); NSLog(@\"%@\",[NSThread currentThread]); &#125;); &#125; Dispatch Group组的概念,如果我们希望在一些异步任务完成后做一些结果处理,通常,我们会使用串行队列.并把处理操作追加到最后,但是如果需要使用并行队列,或者需要多个队列时,那么代码就会异常的复杂,还好GCD为我们提供给我们Group的概念. 12345678910111213141516171819dispatch_queue_t conCurrentQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group=dispatch_group_create(); for (int i=0; i&lt;100; i++) &#123; dispatch_group_async(group, conCurrentQueue, ^&#123; sleep(0.5); NSLog(@\"concurrent--%@\",[NSThread currentThread]); &#125;); &#125; dispatch_group_notify(group, conCurrentQueue, ^&#123; NSLog(@\"Done\"); &#125;); 上面便是Dispatch Group的常见用法 dispatch_barrier_async任务栅栏再讨论dispatch_barrier_async之前我先给大家描述一个需求,如果我们需要在一个并发队列中追加20个任务,需要在做完前10个任务后,开始做后10个任务之前,有一段中场休息,在中场休息的时候不执行任何任务,而且,开始中场休息时,保证前十个任务已经完成,后十个任务还没有开始做.休息之后再继续完成后面的10个任务. 我们知道根据并发队列的特性,这是控制不了的,即使把这20个任务,和中场休息任务都按照正确顺序追加到并发队列中,但是并发队列控制不了结束执行的顺序,有可能前后10个任务结束顺序都混在了一起,更别说要在中场休息的时候不做其它任务.那么这个时候就需要我们任务栅栏:dispatch_barrier_async利用它来将中场休息任务追加到并发队列中,就可以满足我们的上述需求: 1234567891011121314151617181920212223242526dispatch_queue_t conCurrentQueue=dispatch_queue_create(\"queue1\", DISPATCH_QUEUE_CONCURRENT); for (int i=1; i&lt;=10; i++) &#123; dispatch_async(conCurrentQueue, ^&#123; sleep(0.5); NSLog(@\"我做完了第%d件事情\",i); &#125;); &#125; dispatch_barrier_async(conCurrentQueue, ^&#123; sleep(2.0); NSLog(@\"我在中场休息 我在中场休息 我在中场休息 我在中场休息 我在中场休息 我在中场休息 我在中场休息 我在中场休息 \"); &#125;); for (int i=11; i&lt;=20; i++) &#123; dispatch_async(conCurrentQueue, ^&#123; sleep(0.5); NSLog(@\"我做完了第%d件事情\",i); &#125;); &#125; 栅栏就可以保证队列中栅栏前的任务全都执行完毕,开始执行栅栏任务,等待栅栏任务执行完毕,再开始执行栅栏任务之后的任务.清晰的把任务分成了三部分. dispatch_apply多次追加任务到队列这个函数可以代替我们循环追加任务到队列中,但是它和dispatch_sync的等待执行完毕的特性一致,这个函数会等待,直到利用dispatch_sync追加到队伍中的任务全部执行完毕才会执行函数下面的代码,期间会阻塞当前线程,所以适合在非主线程使用. 1234567891011dispatch_queue_t conCurrentQueue= dispatch_queue_create(\"queueName\", DISPATCH_QUEUE_CONCURRENT); dispatch_apply(10000, conCurrentQueue, ^(size_t index) &#123; sleep(0.5); NSLog(@\"我完成了第%zu个任务\",index); &#125;); NSLog(@\"done\"); dispatch_after(延迟执行)我们经常会有希望某段代码延迟一定时间执行. GCD提供给我们相关的函数,让我们可以很轻易的做到延迟执行 123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@\"%@\",[NSThread currentThread]); &#125;); 上述代码在3秒后,进行控制台的打印操作. 严格意义上来说,上述代码并不是3秒后执行,而是3秒后加到主队列中.如果主线程中已经被大量耗时任务堆积时,可能并不准确,但是一般来说还是很可靠的 dispatch_once (一次执行)有时我们希望某一段代码在整个应用程序执行中,只执行一次,那么就用到GCD的dispatch_once这个API了 12345static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"only once\"); &#125;); 这个API即使是在多线程环境下,也能保证百分之百的安全.所以也被开发者们所喜爱.也经常用这个API来写单例模式. dispatch_suspend(队列的暂停)和dispatch_resume(队列的继续)我们有时候希望在某种状况下停止执行队列中的任务.等到某种条件再继续执行. 我们GCD就为我们提供了相应的函数 以下这个demo是在队列处理任务2秒后暂停队列执行任务,5秒后再回复执行 123456789101112131415161718192021dispatch_queue_t queue=dispatch_queue_create(\"queue\", DISPATCH_QUEUE_SERIAL); for (int i=0; i&lt;100; i++) &#123; dispatch_async(queue, ^&#123; sleep(1.0); NSLog(@\"执行完第%d次任务\",i); &#125;); &#125; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; dispatch_suspend(queue); &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; dispatch_resume(queue); &#125;); 其它APIGCD还有一些API,如果感兴趣,大家可以自己搜索资料进行学习,笔者这里就暂时不一一展开了,如果有机会我们后续的文章再一起探讨 dispatch I/O dispatch Semaphore","tags":[]},{"title":"关于Block块的所有所有","date":"2017-03-31T06:14:27.000Z","path":"2017/03/31/关于Block块的所有所有/","text":"关于Block:在我们使用OC进行iOS开发和Mac OS开发中,Block语法是我们最常见的语法之一,而且苹果官方也推荐我们使用Block代码块的语法,如果仔细观察,大家可以看到,在近期苹果新开放的系统框架的API中,苹果越来越多的使用了Block这种语法方式,而不是@selector方法选择器. 苹果如此推荐Block的使用,以及这种语法深受广大OC开发者的喜爱的原因是Block不可替代的优点:Block的写法非常简洁高效,而且可以减少代码的分散,提高内聚性等等,虽然代理等回调方式也有它的优点,但是广大OC开发者确大都对Block情有独钟. 接下来,我们一起来看看Block的用法,原理,以及注意点吧. 初识Block:Block 是在OSX 10.4 以及iOS4 之后引入的新的语法形式,从技术上来讲,Block应该属于C语言的特性,所以只要编译器支持,就可以在C,C++,OC,OC++中使用. 通俗点来说Block的内容其实就是一个代码块,表示一段代码.但是这个代码块可以有返回值,可以有参数 Block也可以看成是一个OC对象,所以它也能赋值给变量. 没有参数,没有返回值的Block说一百句话也不如上一句代码,我们先来写个最简单的Block吧: 123^&#123; NSLog(@\"I am a Block\"); &#125;; 很简单的语法形式对吧,一对{}前面再加上一个^,就是最简单的Block形式,这个Block只有一句代码,没有返回值,也没有参数. 有参数,没有返回值的Block1234^(NSInteger count,NSString *str)&#123; NSLog(@\"%ld---%@\",count,str); &#125;; 这个Block带了两个参数分别是count和str,参数就写在^后面的()中就可以了 有参数,有返回值的Block1234^(NSInteger count,NSString *str)&#123; NSLog(@\"%ld---%@\",count,str); return YES; &#125;; 这个Block不仅有两个参数,还有返回值,返回值的类型是一个BOOL值 这些就是几种Block的类型啦,是不是也没有那么复杂. 把Block赋值给变量上面我们创建了三种类型的Block,但是,我们却无法方便的拿来使用.这个时候,我们需要把这个创建出来的Block赋值给一个变量: 1234BOOL (^aBlock)(NSInteger count,NSString *str)=^(NSInteger count,NSString *str)&#123; NSLog(@\"%ld---%@\",count,str); return YES; &#125;; 我们把上面那个既有返回值又有参数的Block赋值给了一个叫aBlock的变量,这个变量名是写在中间的看起来有点奇怪,但是熟悉了Block的语法就会习惯了,而BOOL (^aBlock)(NSInteger count,NSString *str)表示Block的类型.BOOL表示返回值,(NSInteger count,NSString *str)表示这个Block的两个参数. 通过变量名调用Block我们如果需要调用这个定义的Block,则可以通过变量名如这样: 1aBlock(10,@\"123\"); 这样我们就调用了这个Block,并为这个Block传入了两个参数. 内联Block我们使用Block经常是把Block当做一个参数传出一个方法中,这种用法叫做内联Block. 我们直观的从代码上了解这种用法就好了:123456-(void)aMethodWithInlineBlock:(BOOL(^)(NSString *,NSInteger ))block&#123; if (block) &#123; block(@\"123\",10); &#125;&#125; 上面为一个带Block参数的方法实现,下面是调用这个方法的代码:123456[self aMethodWithInlineBlock:^BOOL(NSString *str,NSInteger count) &#123; NSLog(@\"%@----%ld\",str,count); return YES; &#125;]; Block最大的特性:捕获变量:在Block的诸多特性中,最显著的最强大的特性是可以在Block的声明范围中,捕获需要的变量.实际上,我们可以把Block看做是一个OC对象,所以它也会用引用计数来管理,如果我们在Block中使用了某个外部变量,而该变量是对象类型的话,Block也会对这个变量有一个强引用,当Block本身的引用计数变为0的时候,系统会释放Block,Block也会对所捕获的对象做一次release操作. Block内存结构: 类型 变量名 void * isa int flag int reserved void(*)(void) invoke struct descriptor 捕获到的变量 捕获到的变量 这其中最重要的是invoke这个函数指针,它指向的是Block的实现代码. descriptor是一个结构体,这个结构体中有Block的大小,还有copy,dispose这两个函数指针,分别是在拷贝和丢弃Block的时候调用的. Block会对它捕获到的变量指针做一个拷贝. 在栈中的Block我们定义Block时,Block所占据的其实是栈内存空间,在栈内存空间中,那么我们就无法控制Block的生命周期,ARC也没有办法对这种Block进行引用计数的内存管理,这种Block通常是不安全的,例如: 1234567891011121314void (^aBlock)(); if (self.condition) &#123; aBlock=^&#123; NSLog(@\"123\"); &#125;; &#125;else &#123; aBlock=^&#123; NSLog(@\"456\"); &#125;; &#125; aBlock(); 这段代码其实是不安全的,因为我们定义出来的Block在栈内存中,而我们不能保证在出了Block的定义区域后,这个Block还有效,那么在这种情况下,赋值给aBlock变量是不安全的,然而,我们只要对Block进行一次copy操作,就能在堆内存中拷贝一份Block,这样我们就能对Block的内存进行控制了,ARC也能对copy出来的Block进行内存管理了. 上面的代码如下改就变得安全了: 1234567891011121314void (^aBlock)(); if (self.condition) &#123; aBlock=[^&#123; NSLog(@\"123\"); &#125; copy]; &#125;else &#123; aBlock=[^&#123; NSLog(@\"456\"); &#125;copy ]; &#125; aBlock(); 为Block变量创建别名我们上面说到Block变量名是写在类型中间的,看起来似乎有点奇怪,而且也不是非常有利于易读性,所以,我们一般会为Block类型起一个别名. 之前我们对一个Block变量赋值为这种写法: 123456BOOL (^aBlock)(NSInteger ,NSString *)=^(NSInteger count,NSString *str)&#123; NSLog(@\"%ld---%@\",count,str); return YES;&#125;;aBlock(10,@\"123\"); 我们现在为这种类型的Block起个别名 1typedef BOOL (^ABlock)(NSInteger ,NSString *); ABlock为这种Block的类型名,我们之后再赋值给这种类型的Block就可以如下写了: 123456ABlock aBlock=^(NSInteger count,NSString *str)&#123; NSLog(@\"%ld---%@\",count,str); return YES; &#125;; aBlock(10,@\"123\"); 使用Block最大的注意点:避免循环引用我们刚刚有说过,在Block中,Block会自动捕获要使用到的变量,并持有该变量.这时往往容易出现循环引用的问题,当前类实例持有该Block,该Block又在其中使用self,持有了该实例,这时循环引用问题就出现了. 例如:我们在当前类声明一个Block属性: 1@property (nonatomic,copy)ABlock ablock; 我们给这个Block赋值: 123456self.ablock=^(NSInteger count,NSString *str )&#123; self.view.backgroundColor=[UIColor greenColor]; return YES; &#125;; 这样,由于我们在Block中使用了self,那么这个Block就会把当前实例捕获,并持有,而当前实例又拥有该Block,这就导致了循环引用的状况. 如下修改: 12345678__weak ViewController * weakSelf=self; self.ablock=^(NSInteger count,NSString *str )&#123; weakSelf.view.backgroundColor=[UIColor greenColor]; return YES; &#125;; 我们在该Block中使用了self的若引用,从而打破了这个引用环,解决了循环引用的问题. 特别需要注意的一种情况是对在Block中使用成员变量,引起的循环引用问题容易让开发者们所忽视,因为,在Block中虽然并没有使用self,而是使用的成员变量,但是想要捕获成员变量又一定要捕获self,这依然会导致循环引用.例如: 123456789101112//定义了一个成员变量&#123; NSString *_chengyuanbianliang;&#125;//在Block中使用成员变量,导致循环引用self.ablock=^(NSInteger count,NSString *str )&#123; NSLog(@\"%@\",_chengyuanbianliang); return YES; &#125;; 我们可以如下解决这个问题: 12345678910__weak ViewController * weakSelf=self;self.ablock=^(NSInteger count,NSString *str )&#123; __strong ViewController *strongSelf=weakSelf; NSLog(@\"%@\",strongSelf-&gt;_chengyuanbianliang ); return YES;&#125;;","tags":[]},{"title":"iOS黑魔法-method_swizzling","date":"2017-03-27T04:56:11.000Z","path":"2017/03/27/iOS黑魔法-method-swizzling/","text":"前言:今天我们再来了解另外一个体现OC动态特性的技术,向来有IOS黑魔法之称的Method Swizzling,中文叫做方法调配,也叫做方法交换技术 这项技术为什么能够有如此的盛名呢?我们来看看它到底能做什么吧,Method Swizzling技术能够在运行期间动态的交换两个方法的实现,神不知鬼不觉的把一个方法实现代码交换掉,而可以方法交换的类不仅仅限制于我们自己编写的类,还可以把系统的类中的方法实现交换掉,这就为我们带来了无限的发挥空间.我们可以在没有系统类源代码的情况下,修改系统方法的实现,想想是不是非常酷. 注意:虽然这项技术非常强大,但是我们并不建议滥用这项技术,和其它运行时技术一样,如果出现问题以后,编译器并不能帮我们发现,这将会使得排查错误是一件非常困难的事情 原理:这么强大的技术,到底是基于什么实现的呢? 实际上这项技术是基于OC的动态绑定技术实现的,动态绑定简单的说就是我们OC对象直到运行时才把这个对象所具有的方法和属性绑定到对象上.这些方法和属性有我们类中原先实现的,也有动态生成的,还有替换掉原来实现的. 有了这项强大的技术,我们就可以在运行时动态的修改方法实现了. 大家应该知道我们对象的方法都在对象的isa指针所指的class的方法列表中,这个列表维护的一张selector名称和imp的映射表,那我们的Method Swizzling实际上就是篡改这个表的映射关系,从而达到方法交换的目的. 应用:Method Swizzling 有着相当广泛的应用场景,因为这项技术不仅能交换我们自己编写的方法,还能交换系统方法,从而可以在系统方法中添加一些功能,或者直接全部修改实现. 我们现在就举一个经典的例子: 在OC中,我们知道,如果向数组和字典里面添加nil,那么将会导致程序崩溃,但是我们时常会遗漏掉判空操作,就向数组或字典里添加数据了. 那么这里我们可以采用Method Swizzle来对修改数组添加对象的方法,让系统在添加前先对数据进行判空操作 首先,我们看一下正常的向数组中添加对象的操作: 123NSMutableArray *array=[@[] mutableCopy]; id obj =@\"1\"; [array addObject:obj]; 一切正常 如果我们把上面的代码增加一句变为这样: 1234NSMutableArray *array=[@[] mutableCopy]; id obj =@\"1\"; obj=nil; [array addObject:obj]; obj在赋值前被置为nil,当这段代码运行时,不出所料的崩溃了,以下是崩溃堆栈: 12340 CoreFoundation 0x0000000107bffd4b __exceptionPreprocess + 171 1 libobjc.A.dylib 0x000000010766121e objc_exception_throw + 48 2 CoreFoundation 0x0000000107b3075f -[__NSArrayM insertObject:atIndex:] + 1375 3 MethodSwizzling 0x000000010708c6dc -[ViewController touchesBegan:withEvent:] + 156 可以看到,我们系统内部向数组中添加对象调用的方法为[__NSArrayM insertObject:atIndex:]而且调用方法的实例的类为__NSArrayM这个类为实际的在运行时的创建的数组的类,至于,为什么是__NSArrayM而不是NSMutableArray,这涉及到了类簇class clusters的知识,大家请自行查阅相关概念,或者等到后期我再和大家专门探究. 发现了调用的方法和调用方法的实例的真实类,接下来我们就可以很方便的做方法交换了 我们先为NSMutableArray写一个category,在这个category的.m文件中我编写了以下代码: 1234567891011121314151617181920+(void)load&#123; Class class=NSClassFromString(@\"__NSArrayM\"); Method methodOri= class_getInstanceMethod(class, @selector(insertObject:atIndex:)); Method methodNew=class_getInstanceMethod(class, @selector(CXinsertObject:atIndex:)); method_exchangeImplementations(methodOri, methodNew); &#125;-(void)CXinsertObject:(id)anObject atIndex:(NSUInteger)index&#123; if (anObject==nil) &#123; return; &#125; [self CXinsertObject:anObject atIndex:index];&#125; 我们可以看到我先重写了NSMutableArray的load方法,在这个方法里我们将会进行方法交换操作,这里要和大家解释一下,load方法往往是最适合做方法交换的位置.这个方法只会执行一次而且在类文件加载到程序中时,就会执行,所以做方法交换非常恰当. 再来分析一下上面的代码,因为class clusters在系统中的大量使用,我们要先确定数组对象真实的类 由上面的崩溃堆栈我们看到真实的类名叫做__NSArrayM,那么我们通过字符串取到这个类 接下来为取到这个类实际调用的方法对应的Method,以及与系统类实现需要交换的Method,并进行交换 这里我们需要写一个方法CXinsertObject在这个方法里,我们为原来的实现添加判空操作,看到这个方法中的[self CXinsertObject:anObject atIndex:index];这句代码,很多同学一定会困惑,这不是成死循环调用了吗?我要告诉天真的你不是的!因为在执行到这个方法时,方法已经交换了,这里实际上会运行的是系统本身的方法,这样在方法交换后我们就实现了判空处理后再调用系统添加的方法. 通过上面一系列的操作,我们就在不知道系统源码的情况下,修改了系统类的实现 这样,当我们对再向数组中添加nil时,程序就不会再崩溃啦! 字典的大致处理也基本一致,大家可以自行尝试一下,还有在初始化数组字典时其中若有nil也会导致崩溃,我们也能够进行类似的处理,大家快动手试试吧!","tags":[]},{"title":"消息转发机制","date":"2017-03-27T04:54:41.000Z","path":"2017/03/27/消息转发机制/","text":"前言今天我们再来通过另外一个机制来感受一下OC的动态特性吧,那就是OC的消息转发机制 在之前的不一样的OC中我们有提到,OC是消息型语言,OC中的方法调用其实只是传递消息而已,编译器并不能决定程序真正执行的到底是哪段代码,这个工作,需要运行时系统来完成. 那我们今天要讨论的消息转发又是什么呢? 既然OC的方法调用实际上都是消息传递,那传递的消息内容和时机其实编译器并不能完全控制,这时我们是不是能够联想到这样的场景:一个对象接受了一个编译器控制外的消息,这个对象对这个消息无从下手,他并不具备解决这个消息的能力(没有实现相应方法),这个时候该怎么办呢? 当遇到这种情况的时候,我们的消息转发机制就被触发了,系统将利用这套机制竭力帮我们控制这个糟糕的局面,不至于让程序崩溃,但是如果消息转发机制竭尽全力通过各种办法也无法解决这个意料之外的消息时,那么程序就会崩溃,并产生那个经典的崩溃日志: 12unrecognized selector sent to instance 0x60000000b480 消息转发机制的三部曲消息转发机制在极力为我们收拾残局的时候,会有三步措施,如果在最坏的情况下,这三个步骤将会按顺序依次执行,如果这三个步骤都无法挽回,那么程序将会崩溃,值得一提的是:如果消息转发机制的某一个步骤就能解决这个问题,那么下一个步骤就不会执行了,消息转发机制就到此为止了(事情都解决了,当然不需要下一步了) 我们现在用一个简单的例子来触发消息转发机制,并利用消息转发机制解决问题 我新建了一个叫做Person的类,并在它的.h文件里为Person声明了一个实例方法:run 以下是.h文件的内容. 12345678#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject-(void)run;@end 大家猜猜我在.m文件里做了什么?以下是.m文件的内容: 12345#import \"Person.h\"@implementation Person@end 哈哈,我什么都没做,甚至没有对.h中的run方法写实现. 我为什么要这么做呢?这样我们就可以欺骗编译器,在调用这个方法的时候,编译器默认我们已经对这个方法写了实现,他就会让我们舒舒服服的调用这个方法,并不会报错,组织我们队这个方法的调用 那接下来,我们在控制器中新建一个person对象,并调用这个方法的run方法 123Person *p1=[Person new]; [p1 run]; 大家应该猜的到会发生什么了吧,我们能够成功编译并运行这个程序,但是当代码执行到了run方法时,程序崩溃了,并报了我们常见的那个错误unrecognized selector sent to instance 0x60000000b480 大家一定想知道这其中到底发生了什么事情:当run方法被调用时,运行时系统就会对p1这个对象发送一条run的消息,意料之中的是p1这个对象并不能对相应这个消息,因为我们没有写run的实现方法,那接下来就会触发消息转发机制了,那既然触发了消息转发机制,为什么还是崩溃了呢,因为,这就是那种最坏的情况,消息转发机制三个步骤依次执行却依然没有挽回崩溃的结果. 那么我们快看一看怎么让消息转发机制发挥作用吧. 步骤一:能不能动态添加一个函数解决这个消息啊在这一步中,面对无法解决的消息,消息转发机制首先做的是,看看能否动态添加一个方法实现,来解决这个消息. 如果是实例方法,系统会调用这个这个实例所属类的类方法: 1+(BOOL)resolveInstanceMethod:(SEL)sel 如果是类方法: 1+(BOOL)resolveClassMethod:(SEL)sel 这对方法如何使用呢?我们来看: 我在person类的.m文件中写了如下代码: 1234567891011121314+(BOOL)resolveInstanceMethod:(SEL)sel&#123; if (sel==@selector(run)) &#123; class_addMethod(self, sel, (IMP)run , \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void run (id self,SEL _cmd)&#123; NSLog(@\"fdfsfaf\");&#125; 我们写了一个run的c语言函数,当消息机制触发时,selector为run时那么就会利用运行时库动态添加一个方法,而这个方法的函数实现是我们用C写的一个函数,这个函数的两个参数为self,和_cmd,因为OC方法的本质就是至少包含两个参数的C函数这两个参数便是隐藏的self,和_cmd,前者是消息接受者,后者是一个SEL指针 通过这样的操作,系统就为我们通过动态添加一个方法的方式来解决了这个不能响应的消息这也是消息转发机制的第一步,如果这一步并没有解决这个问题,那便要有下面的步骤了. 步骤二:能不能找别人处理这个消息啊当上一步没有解决这个问题的时候,这一步,系统将会通过寻找有没有别的对象可以帮忙处理这条消息. 系统会调用如下方法:1234-(id)forwardingTargetForSelector:(SEL)aSelector&#123; return [RunPerson new];&#125; 大家可以看到,我在这个方法中返回了一个新的类RunPerson的实例,而在这个类的.m文件中,我写了如下实现:1234-(void)run&#123; NSLog(@\"我是会跑的人,我能跑!\");&#125; 通过返回一个新的类,我们把这个消息转发给了一个其它对象,让这个对象来代替我们解决这个消息. 步骤三: 完整的消息转发在这一步中,消息转发机制将进行最后一步操作 我在Person的.m文件中写了如下代码,将会使得run消息,在消息转发机制最后一步得到处理 123456789101112131415161718192021222324-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; if (aSelector==@selector(run)) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"]; &#125; return [super methodSignatureForSelector: aSelector];&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; SEL selector =[anInvocation selector]; RunPerson *RP1=[RunPerson new]; RunPerson *RP2=[RunPerson new]; if ([RP1 respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:RP1]; &#125; if ([RP2 respondsToSelector:selector]) &#123; [anInvocation invokeWithTarget:RP2]; &#125; &#125; 第一个方法返回的是一个方法签名,而代码中的v@:表示这个函数的性质,v代表返回值为void,@代表self,:代表_cmd; 当有了方法签名,消息转发机制将会调用-(void)forwardInvocation:(NSInvocation *)anInvocation方法,这个方法的参数anInvocation为这个消息的全部内容,包括调用者,参数等等. 在这个方法里我们初始化了两个RunPerson实例,并把这个Invocation转发给了这两个RunPerson实例,这样,这两个RunPerson对象就都会对这个消息进行处理了这也是与第二个步骤最大的区别,可以转发给多个对象进行处理. 到此,消息转发的三个步骤就结束了,如果到第三步还没有解决这个消息,那么程序就会崩溃了.","tags":[]},{"title":"几种常见的排序算法","date":"2017-03-19T04:24:30.000Z","path":"2017/03/19/几种常见的排序算法/","text":"一 快速排序快速排序是我们平常最常使用的一种排序算法,因为它速度快,效率高,是最优秀的一种排序算法. 它的平均时间复杂度为:O(nlgn) 原理:快速排序采用的是一种分治的思想,它先找一个基准数,然后将比这个基准数小的数字都放到它的左边,然后再递归调用,分别对左右两边快速排序,直到每一边只有一个数字.整个排序就完成了. OC实现:123456789101112131415161718192021222324-(void)quickSort:(NSMutableArray *)list startIndex:(NSInteger )startIndex endIndex:(NSInteger)endIndex&#123; if (list==nil||startIndex&gt;=endIndex) &#123; return; &#125; NSInteger tempIndex=startIndex; NSNumber *tempNumber=list[startIndex]; for (NSInteger i=startIndex+1; i&lt;=endIndex; i++) &#123; if ([tempNumber integerValue]&gt;[list[i] integerValue]) &#123; tempIndex++; [list exchangeObjectAtIndex:tempIndex withObjectAtIndex:i]; &#125; &#125; [list exchangeObjectAtIndex:startIndex withObjectAtIndex:tempIndex]; [self quickSort:list startIndex:startIndex endIndex:tempIndex-1]; [self quickSort:list startIndex:tempIndex+1 endIndex:endIndex]; &#125; 二 冒泡排序冒泡排序在我们实际开发中,使用的还是比较少的.它更加适合数据规模比较少的时候,因为它的效率是比较低的,但是优点是逻辑简单,容易让我们记得. 原理:冒泡排序其实就是逐一比较交换,进行里外两次循环,外层循环为遍历所有数字,逐个确定每个位置,里层循环为确定了位置后,遍历所有后面没有确定位置的数字,与该位置的数字进行比较,只要比该位置的数字小,就和该位置的数字进行交换. OC实现:12345678910111213-(void)bubbleSort:(NSMutableArray *)list&#123; for (int i=0; i&lt;list.count; i++) &#123; for (int j=i+1; j&lt;list.count; j++) &#123; if ([list[i] integerValue]&gt;[list[j] integerValue]) &#123; [list exchangeObjectAtIndex:i withObjectAtIndex:j]; &#125; &#125; &#125;&#125; 三 直接插入排序直接插入排序的平均时间复杂度是:O(n^2) 原理:直接插入排序是将从第二个数字开始,逐个拿出来,插入到之前排好序的数列里.如图: OC实现:1234567891011121314151617181920-(void)insertSort:(NSMutableArray *)list&#123; for (int i=1; i&lt;list.count; i++) &#123; NSInteger value=[list[i] integerValue]; NSInteger j=i-1; while (j&gt;=0&amp;&amp;value&lt;[list[j] integerValue]) &#123; j--; &#125; [list removeObjectAtIndex:i]; [list insertObject:@(value) atIndex:j+1]; &#125; &#125; 四 直接选择排序直接选择排序的平均时间复杂度是:O(n^2),和冒泡排序一样,逻辑简单,但是效率不高,适合少量的数据排序 原理:直接选择排序是从第一个位置开始遍历位置,找到剩余未排序的数据里最小的,找到最小的后,再做交换 OC实现:1234567891011121314151617-(void)selectSort:(NSMutableArray *)list&#123; for (int i=0; i&lt;list.count; i++) &#123; int k=i; for (int j=i+1; j&lt;list.count; j++) &#123; if ([list[j] integerValue]&lt;[list[k] integerValue]) &#123; k = j; &#125; &#125; [list exchangeObjectAtIndex:i withObjectAtIndex:k]; &#125;&#125; 与冒泡排序的区别:冒泡排序法是两两依次比较，并做交换，交换的次数多。选择排序法是每次循环找出最值，循环结束后将最值调整到合适位置，交换的次数少。 剩余常见排序算法:归并排序,希尔排序,堆排序,基数排序,桶排序.","tags":[]},{"title":"动态添加属性-Associated Object","date":"2017-03-13T09:56:26.000Z","path":"2017/03/13/动态添加属性-Associated Object/","text":"前言从今天开始,我们将要开始逐步接近OC的动态特性,慢慢揭开OC底层runtime系统的神秘面纱,超强的动态特性,是OC和一般面向对象的语言最明显的区别,也是这门古老的语言最具魅力的地方,如果可以正确的利用动态特性,那么可以帮助我们方便的解决很多棘手的问题. 我们今天来看的呢,是runtime库里非常有用的一组函数,Associated Object动态关联对象.这个功能,能够让我们动态的对一个对象绑定相关联的数据. 有了这个功能,我们不仅能够为自己编写的类添加属性,还能够为系统框架里的类动态添加我们需要的属性,甚至能够在分类里动态添加属性.我们这就来看看这个方便又强大的功能吧. Associated Object使用场景我们都有这样的经验,我们希望在既有的类上添加新的属性,通常情况下: 如果这个类是我们自己编写的,那么我们就可以方便的在文件中添加对应的属性就可以 如果这个类是系统框架的,而并非我们自己编写的,那么,我们通常会采取集成该系统类,产生新的类,添加我们需要的方法和属性 但是,很多时候,某个对象并不是我们产生,而是通过其它机制产生的,比如,系统为我们返回了一个系统类的实例,但是,我们却希望在这个实例加上这个类原本并没有的属性,来记录或存储一些数据,在这个时候我们按照常规的方法就不好解决了. 这时,我们的Associated Object就要发挥它的作用了. 相关函数Associated Object的相关函数在runtime.h 文件中,使用前,我们需要先引入该库.而该库中和Associated Object相关的函数有三个: objc_setAssociatedObject:用来给对象动态绑定关联对象(也就是添加相应属性) objc_getAssociatedObject:用来读取对某对象动态绑定的关联对象(读取相应属性) objc_removeAssociatedObjects:这个函数是用来解除某对象的所有关联对象这项操作会将该对象所有的关联对象都全部删除.使用时,我们要格外注意. Associated Object存储策略:在调用objc_setAssociatedObject:函数时,我们需要设置关联对象的存储策略,这类似于property属性的存储策略关键字,这些存储策略名称从字面上就可以轻易的与property属性的存储策略关键字轻松匹配,相信大家一定可以选对的.我就不再一一举例了. Associated Object存储策略 property属性存储策略关键字 OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic, strong OBJC_ASSOCIATION_COPY_NONATOMIC copy, nonatomic OBJC_ASSOCIATION_RETAIN strong OBJC_ASSOCIATION_COPY copy 示例说了这么多,我们通过一个小小的例子,来感受下Associated Object的妙用吧 我们都有过这样的经历,我们需要在用户进行过某些操作的时候触发一个提醒框,即AlertView. 通常代码会像这个样子: 1234567891011121314151617-(void)click&#123; UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@\"alert\" message:@\"msg\" delegate:self cancelButtonTitle:@\"cancle\" otherButtonTitles:@\"confirm\", nil]; [alert show];&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (buttonIndex==0) &#123; NSLog(@\"do someThing\"); &#125;else &#123; NSLog(@\"do otherThing\"); &#125;&#125; 但是经常我们会在一个控制器中有多个潜在将会触发的提醒框,如果是这样,那么我们通常会为alertView指定tag,在代理方法里区分不同的提醒框,做不同处理,那么代码就会变成这个样子. 12345678910111213141516171819202122232425262728293031323334353637-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; if (alertView.tag==0) &#123; if (buttonIndex==0) &#123; NSLog(@\"do someThing\"); &#125;else &#123; NSLog(@\"do otherThing\"); &#125; &#125;else if (alertView.tag==1) &#123; if (buttonIndex==0) &#123; NSLog(@\"do someThing\"); &#125;else &#123; NSLog(@\"do otherThing\"); &#125; &#125;else if (alertView.tag==2) &#123; if (buttonIndex==0) &#123; NSLog(@\"do someThing\"); &#125;else &#123; NSLog(@\"do otherThing\"); &#125; &#125;else if (alertView.tag==3) &#123; if (buttonIndex==0) &#123; NSLog(@\"do someThing\"); &#125;else &#123; NSLog(@\"do otherThing\"); &#125; &#125;&#125; 这样的代码,不仅繁琐冗长,并不利于我们的代码可读性和高内聚低耦合的设计原则 我们将要通过Associated Object方式,对该情况进行处理 大概思路为,在编写alertView时为每一个alertView关联一个处理Block,在代理方法中我们只要调用alertView关联的处理block就可以了,这样的代码将会变得异常清晰,而且具有极高的可读性我们一起来看一下吧: 我们需要先导入需要的文件,并声明一个用来充当关联Key的字符常量: 1234#import &lt;objc/runtime.h&gt;static char const alertDealBlockKey; 然后在编写提示框的时候,我们需要编写一个处理alertView的block,并和alertView进行关联: 12345678910111213141516171819-(void)click&#123; UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@\"alert\" message:@\"msg\" delegate:self cancelButtonTitle:@\"cancle\" otherButtonTitles:@\"confirm\", nil]; void (^alertDealBlock)(NSInteger btnIndex)=^(NSInteger btnIndex)&#123; if (btnIndex==0) &#123; NSLog(@\"do someThing\"); &#125;else &#123; NSLog(@\"do otherThing\"); &#125; &#125;; objc_setAssociatedObject(alert, &amp;alertDealBlockKey, alertDealBlock, OBJC_ASSOCIATION_COPY_NONATOMIC); [alert show]; &#125; 这样处理过得alertView中就会绑定一个处理的block了,接下来我们在alertview的代理方法中,仅仅需要将这个block取出并调用,就可以了: 12345678-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex&#123; void (^alertDealBlock)(NSInteger btnIndex)=objc_getAssociatedObject(alertView, &amp;alertDealBlockKey); alertDealBlock(buttonIndex); &#125; 这样无论该文件中将有多少个alertView,我们的代理方法中也只需要这样短短两行的代码就可以处理,是不是很简单呢,而且,在编写alertView的时候我们就可以顺便把处理方式编写好,可读性也大大提高,是不是还是很优雅的呢? 总结上面的这个例子只是一个Associated Object一个简单使用,还有很多妙用等待大家发现,Associated Object之所以能够动态的为实例添加关联对象,这要依附于我们强大的运行时系统,这点大家要好好理解,最后虽然Associated Object非常好用,但是也不建议大家滥用,只有在别的方式都不可行的情况下才建议大家使用关联对象处理,因为如果你的编码有误,产生问题将非常难于查找,因为编译器并不能够检测出运行时才会关联的对象的相关问题,对于关联对象,编译器是有心无力的,保证它的正确性只能我们人为去检测验证","tags":[]},{"title":"看破property-属性","date":"2017-03-10T05:57:38.000Z","path":"2017/03/10/看破property-属性/","text":"前言今天和大家一起来探讨一下OC中的property(属性)这一概念. OC用property来封装对象里的数据,通过property,可以让编译器创建一个实例变量来保存数据,并且创建对应的一对存取器方法,来进行对该数据的访问. 有了property之后,我们便可以方便的使用点语法来访问对象中所封装的数据了,实在是方便的很. 不过property还是有诸多细节值得我们讨论的,下面,我们一一对其探讨. property的实质@property语法,其实是一种语法糖,也就是说,它其实就是一个下划线实例变量和一对存储器方法的集合 1@property NSString *name; 上面这种语法和下面这种写法是等效的: 123456789101112&#123; NSString * _name;&#125;-(NSString *)name&#123; return _name;&#125;-(void)setName:(NSString *)name&#123; _name=name;&#125; 我们再编写@property属性的时候编译器会在编译期为这些属性生成访问这些属性所需的存取器方法,这个过程叫做自动合成(autosynthesis) 除了存取器方法之外,编译器也会自动生成对应的实例变量名字–在property名字之前加上’_’来作为新生成的实例变量的名字. property的特质在这里需要注意的就是,属性后的特质语义会影响编译器所生成的存取方法.这些特质语义分成四个方面: 原子性原子性特质语义分为:atomic和nonatomic两种,如果不对原子性特质显示说明,则系统默认为atomic保留其原子性,使用同步锁. 虽然拥有这两种原子性的语义,但是,大家能发现,我们一般是使用nonatomic来标明属性的,这是因为atomic的使用在iOS开发中会带来性能瓶颈,而且,并不一定真的能保证线程安全,如果要线程安全,需要更深层次的同步锁. 在OSX开发中atomic通常不会带来性能瓶颈. 读写权限读写特质分为:readwrite和readonly两种,默认为readwrite如果该属性说明为readonly则编译器不会为该属性生成set方法. 内存管理内存管理相关有以下几种语义: assign:此语义表明的属性,其设置方法只会对纯量类型的实例变量进行简单的赋值操作,例如:(NSInteger)类型,所以此种语义并不适合OC对象. strong:此语义为该OC对象属性定义了一种”拥有关系“,这种语义会先保留新值,然后释放旧值,最后设置为新值. weak:weak语义为该OC对象定义了一种”非拥有关系“,这种语义并不会拥有该对象,而仅仅是简单的指向该对象,值得,当拥有该对象的其它对象都对其释放后,它便会销毁,而用weak语义指向它的属性会被置为nil,值得一提的是,如何变为nil而并不是野指针,这项操作涉及到了运行时相关的一些内容,我们日后再详细讨论. unsafe_unretained:这种语义很不常用,原因是它和weak类似,表示一种非拥有关系,但是和weak不同的是,当所指向的对象被销毁时,它的值并不会置为nil,所以是不安全的,一般并不适用. copy: 这种语义表示的也是一种拥有关系,和strong不同的是,该语义并不是保留新值,而是copy拷贝一份新的值,常常用来在NSString类型的属性时适用,因为:很有可能该字符串实际是指向NSMutableString类型的实例,这一点涉及到类族在foundation框架中的大量适用,我们以后会详细,说明,除此之外,所有可变类型的属性,都应该在设置值时copy一份. 当我们重写被赋予了copy语义的属性的set方法时以及对成员变量直接赋值时,我们应该遵守copy语义,应该如下写: 1234-(void)setName:(NSString *)name&#123; _name=[name copy];&#125; 默认的属性特质语义有:atomic,assign,readwrite","tags":[]},{"title":"不一样的OC","date":"2017-03-09T09:01:15.000Z","path":"2017/03/09/不一样的oc/","text":"前言想了很久第一篇技术博客从什么地方写起呢,最后决定还是从我们iOS开发中每天都要使用的OC聊起. 这门语言我想大部分iOS开发者对它都是既熟悉又陌生的,熟悉是因为它我们已经习惯了它那与众不同的语法格式,甚至时间长了,我们还觉得这种长长的方法名调用,还是蛮优雅的么,对它的接口,扩展,分类,协议,这些常规用法都熟悉的不得了,但是说它陌生,是因为在有了ARC(自动引用计数)技术之后,我们对它的引用计数规则就开始一知半解;对它和C语言的关系呢也不太看得明白,对那神奇的动态特性更是望而却步. 今天我就和大家一起慢慢回首看一下我们每天都在使用的,既熟悉又陌生的OC,一睹它的真容. 因为内容较多,我会在后面的博文中,重点对OC的一些关键技术做详细探讨,在这里不过早展开讨论. 初识OC长长的方法名刚接触OC时,我们最初最直观的印象肯定是那长长的方法名,和方括号方式的方法调用,这样与众不同,恩,我喜欢,符合我的性格!和别的语言长得那么像干什么呀,容易省美疲劳么.哈哈,言归正传,这样长长的方法名对于一些C++或是java程序员来说可能不太适应,但是它却有着无与伦比的优点,那就是它的易读性,我们可以很轻易的从方法名来判断出方法的功能,而不需要去查文档才能知道它应该如何调用,这么方便的特性,方法名长点,又如何. OC和C的关系OC可以说是C的超集,它在C语言上添加了面向对象的特性,所以呢,我们想要编写出来优秀的OC代码,也应该熟悉C语言的语法,这也对我们理解OC的引用计数机制添了一对翅膀. 消息传递,而不是函数调用OC是典型的消息型语言,它和函数型的语言最关键的区别在于:它在运行的时候所执行的代码,是由当时的环境决定的,而函数调用语言,早在编译期,就由编译期决定了,OC的这种动态特性,为这门语言增添了无限的魅力.到底如何由环境结束,我们下面会详细探讨. 引用计数机制来管理内存我们知道OC对象的内存是由引用计数机制来管理的,即使是开启了ARC,这一原则也从来没有变过.同学乖,我们后面再来详细探讨. OC使用的注意点 我们应该尽可能少的使用#import来引入头文件,除非在必要的时候,这样可以降低类之间的耦合,可以减少编译时间. 我们在使用foundation框架中的NSString NSArray NSDictionay NSNumber的时候,尽量使用字面量语法(简写写法)不是方法调用. 例如我们可以这样创建这些对象: ​ 1234567891011NSString *str=@\"someString\";NSNumber *num=@2.0f;NSDictionary *dic=@&#123;@\"K1\":@\"V1\",@\"K2\":@\"V2\"&#125;;NSArray *array=@[@\"1\",@\"2\",@\"3\"];NSMutableDictionary *mutableDic=[@&#123;&#125; mutableCopy];NSMutableArray *mutableArray=[@[] mutableCopy]; 这样创建的对象可读性将会大大提高,不仅如此,这种语法还更加有利于操作数组以及字典对象.如果不适用字面量语法,那么我们的代码会是这个样子的: 12345678NSString *dog=[animalArray objectAtIndex:1];NSString *V1=[dic objectForKey:@\"K1\"];[mutableArray replaceObjectAtIndex:1 withObject:@\"otherObj\"];[mutableDic setObject:@\"V3\" forKey:@\"K3\"]; 那么使用了字面量语法后,我们的代码就可以变成这样 1234567NSString *dog=animalArray[1];NSString *V1=dic[@\"K1\"];mutableArray[1]=@\"otherObj\";mutableDic[@\"K3\"]=@\"V3\"; 这样的写法更加简明扼要,但是如果使用字面量语法,向数组或者字典里添加nil时,则会抛出异常,我们要确保没有nil加入. 我们应该尽可能少的使用#define宏定义指令 如果只在某个文件使用某一符号变量应该使用static const来声明常量,因为#define宏定义指令并不包含类型信息,也就是说我们如果把它用在不该用的地方,编译器也不会为我们报错或者提出警告,这是非常不好的.如果是全局常量 如果是全局使用,我们可以声明全局常量,在.m文件的方法外定义,例如: 1NSString * str=@\"someStr\"; 我们可以在.h文件中使用下面语句在使用的文件中导入此.h文件便可以正常使用,也可以不在.h中声明,直接在要使用的文件中使用下面语句声明,不需导入.h文件也可以正常使用. 1extern NSString * str; 用枚举类型来表示状态,选项等,而不是用没有任何含义的数字来表示 这样做非常能够提高我们的代码可读性和编码效率. 用下面这种方式来表示状态 123456typedef enum : NSUInteger &#123; StatusTop = 0, StatusLeft = 1, StatusRight = 2, StatusBottem = 3,&#125; StatusType; 用下面这种方式来表示选项,这种方式可以很轻松的用位运算符,操作选项,多选等操作 12345typedef NS_OPTIONS(NSUInteger, MyOption) &#123; OPtionLeft = 1 &lt;&lt; 0, OPtionTop = 1 &lt;&lt; 1, OPtionRight = 1 &lt;&lt; 2,&#125;;","tags":[]}]